#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
NNUE USI Proxy (YaneuraOu系想定)
- bestmove は最強維持 + 安全フィルタ（強さを歪めない）
- 候補提示は Winability（人間が勝ち切れる可能性）で整形
- 頓死回避：見えてる mate負 除外 + 採用手に対する短時間安全確認（着手後追加探索）
- 低Winability時は Initiative 重視の「下駄を預ける」候補も提示対象
- モード：
    PLAY    : bestmove最強維持（安全のみ）、候補表示は最小
    WATCH   : bestmove最強維持（安全のみ）、候補表示＋役割＋方針ストーリー
    ANALYZE : 候補数増、Winability順提示（内訳も）

[Patch (executed)]
- safety_check_after_move の終了時に base_position を再送して局面を「必ず」復元（状態汚染防止）
- safety_check の mate+ を “短手数は即unsafe / 長手数は複数回観測でunsafe” にして誤検出を減らす
- safety_check 中だけ recv timeout を短くして重さを減らす（READ_TIMEOUTは変更しない）

[New Patch]
- USI stdin を別スレッドで読む：go中でも stop/ponderhit/quit を即座に処理（USI的に必須）
- 子エンジン起動の cwd をこのスクリプトのフォルダに固定（eval/book相対パスの安定化）
- エンジンが実際に持つ option を usi 出力から収集し、存在するものだけ setoption（No such option排除）
- 表示の改善：
    - 「方針（勝ち筋ストーリー / Winability側）」を1行で表示（ヒステリシスでブレにくい）
    - 候補は「役割ラベル」で表示（本線/手堅い/圧/揺さぶり/粘り/勝負手）
    - 候補手を将棋表記（例：７六歩）＋USI併記に変換（簡易KIF）
- 追加：ゲームフェイズ（手数依存しない）
    - 指標：ContactSoonCount / AttackReadiness / PVContactSoon
    - EWMA で平滑化してからヒステリシス判定
    - ショック遷移（急変時は上方向に飛び越え可）
"""

import os
import sys
import subprocess
import threading
import queue
import time
import math
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, Set

# =========================
# PATH / CWD 固定
# =========================
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))

def _abspath_under_script(p: str) -> str:
    if not p:
        return p
    if os.path.isabs(p):
        return p
    return os.path.join(SCRIPT_DIR, p)

# =========================
# CONFIG (環境変数で上書き可)
# =========================
ENGINE_PATH = os.environ.get("TASO_ENGINE", "./YaneuraOu")
NNUE_PATH   = os.environ.get("TASO_NNUE", "eval")  # evalフォルダ想定が安全

ENGINE_PATH_ABS = _abspath_under_script(ENGINE_PATH)
NNUE_PATH_ABS   = _abspath_under_script(NNUE_PATH)

ENGINE_CMD = [ENGINE_PATH_ABS, "-eval", NNUE_PATH_ABS]

THREADS = int(os.environ.get("TASO_THREADS", "6"))
HASH_MB = int(os.environ.get("TASO_HASH_MB", "4096"))

DEFAULT_MULTIPV = int(os.environ.get("TASO_MULTIPV", "3"))
PREFIX_K = int(os.environ.get("TASO_PREFIX_K", "6"))

DIFF_TAU = float(os.environ.get("TASO_DIFF_TAU", "2.5"))  # opp_diff smoothness (bigger=flatter)
INIT_TAU = float(os.environ.get("TASO_INIT_TAU", "3.0"))  # initiative smoothness
STAB_TAU = float(os.environ.get("TASO_STAB_TAU", "2.0"))  # stability weighting
WINABILITY_SPREAD = float(os.environ.get("TASO_WIN_SPREAD", "0.85"))  # compress winability diffs (0.5..1.0)

GOOD_CP_MARGIN = int(os.environ.get("TASO_GOOD_CP_MARGIN", "150"))
DROP_SOFT_LIMIT = int(os.environ.get("TASO_DROP_SOFT_LIMIT", "200"))
DROP_DISTURB_LIMIT = int(os.environ.get("TASO_DROP_DISTURB_LIMIT", "450"))
GOOD_COUNT_CAP = int(os.environ.get("TASO_GOOD_COUNT_CAP", "5"))
GOOD_COUNT_CAP = max(2, min(10, GOOD_COUNT_CAP))
GOOD_TAU = float(os.environ.get("TASO_GOOD_TAU", "3.0"))
# 表示用：winability の見た目を少し圧縮して「他が悪く見えすぎる」を緩和
DISP_WIN_CONTRAST = float(os.environ.get("TASO_DISP_WIN_CONTRAST", "0.85"))
MATE_SHORT_MAX = int(os.environ.get("TASO_SHORT_MATE_MAX", "7"))

MATE_RISK_FLOOR = float(os.environ.get("TASO_MATE_RISK_FLOOR", "0.75"))
MATE_RISK_TAU   = float(os.environ.get("TASO_MATE_RISK_TAU", "10.0"))
MATE_INIT_FLOOR = float(os.environ.get("TASO_MATE_INIT_FLOOR", "0.60"))
MATE_INIT_TAU   = float(os.environ.get("TASO_MATE_INIT_TAU", "8.0"))

SAFETY_MS = int(os.environ.get("TASO_SAFETY_MS", "40"))

SHOW = os.environ.get("TASO_SHOW", "1") == "1"
DEBUG = os.environ.get("TASO_DEBUG", "0") == "1"

READ_TIMEOUT = float(os.environ.get("TASO_READ_TIMEOUT", "0.1"))
LINE_LIMIT = int(os.environ.get("TASO_LINE_LIMIT", "200000"))

GO_HARD_SEC = float(os.environ.get("TASO_GO_HARD_SEC", "60.0"))
GO_STOP_GRACE_SEC = float(os.environ.get("TASO_GO_STOP_GRACE_SEC", "3.0"))

# safety_check deadline（比例型）
SAFETY_DEADLINE_MIN_SEC = float(os.environ.get("TASO_SAFETY_DEADLINE_MIN_SEC", "0.20"))
SAFETY_DEADLINE_FACTOR  = float(os.environ.get("TASO_SAFETY_DEADLINE_FACTOR", "3.0"))
SAFETY_DEADLINE_PAD_SEC = float(os.environ.get("TASO_SAFETY_DEADLINE_PAD_SEC", "0.05"))
SAFETY_STOP_GRACE_SEC   = float(os.environ.get("TASO_SAFETY_STOP_GRACE_SEC", "0.25"))

# safety_check中だけ短いtimeout
SAFETY_READ_TIMEOUT = float(os.environ.get("TASO_SAFETY_READ_TIMEOUT", "0.02"))
SAFETY_MATE_MAX = int(os.environ.get("TASO_SAFETY_MATE_MAX", str(MATE_SHORT_MAX)))
SAFETY_MATE_REPEAT = int(os.environ.get("TASO_SAFETY_MATE_REPEAT", "2"))

# book が無いなら自動でOFF（ノイズ削減）
AUTO_DISABLE_BOOK = os.environ.get("TASO_AUTO_DISABLE_BOOK", "1") == "1"
BOOK_FILE = os.path.join(SCRIPT_DIR, "book", "standard_book.db")

# 表示: 将棋表記に変換するか
SHOW_KIF = os.environ.get("TASO_SHOW_KIF", "1") == "1"

# --- 勝ち筋ストーリー（Winability側）のヒステリシス（ブレ防止） ---
PH_STABLE_ENTER = float(os.environ.get("TASO_PH_STABLE_ENTER", "0.78"))
PH_STABLE_EXIT  = float(os.environ.get("TASO_PH_STABLE_EXIT",  "0.72"))
PH_BAL_ENTER    = float(os.environ.get("TASO_PH_BAL_ENTER",    "0.58"))
PH_BAL_EXIT     = float(os.environ.get("TASO_PH_BAL_EXIT",     "0.52"))
PH_DIST_ENTER   = float(os.environ.get("TASO_PH_DIST_ENTER",   "0.38"))
PH_DIST_EXIT    = float(os.environ.get("TASO_PH_DIST_EXIT",    "0.32"))

# --- ゲームフェイズ（手数非依存） ---
GP_EWMA_ALPHA = float(os.environ.get("TASO_GP_EWMA_ALPHA", "0.35"))   # A: 平滑化
GP_HYS_GAP    = float(os.environ.get("TASO_GP_HYS_GAP", "0.08"))      # B: ヒステリシス幅

# 主要境界（enter）。exit は enter - GP_HYS_GAP を使う
GP_PROBE_ENTER  = float(os.environ.get("TASO_GP_PROBE_ENTER",  "0.26"))
GP_TENS_ENTER   = float(os.environ.get("TASO_GP_TENSION_ENTER","0.50"))
GP_CLASH_ENTER  = float(os.environ.get("TASO_GP_CLASH_ENTER",  "0.72"))

# 勝勢運用/終盤の評価値閾値（cp）
GP_CONVERT_CP_ENTER = int(os.environ.get("TASO_GP_CONVERT_CP_ENTER", "900"))
GP_CONVERT_CP_EXIT  = int(os.environ.get("TASO_GP_CONVERT_CP_EXIT",  "700"))
GP_FINISH_CP_ENTER  = int(os.environ.get("TASO_GP_FINISH_CP_ENTER",  "2500"))
GP_FINISH_CP_EXIT   = int(os.environ.get("TASO_GP_FINISH_CP_EXIT",   "1800"))

# ショック遷移（急戦の急変対応）
GP_SHOCK_PVCS  = float(os.environ.get("TASO_GP_SHOCK_PVCS", "0.85"))
GP_SHOCK_CSC   = int(os.environ.get("TASO_GP_SHOCK_CSC", "6"))

# ---------------------------------------------------------
# Phase polarity (stance) — フェイズに「有利/互角/不利」の視点を掛け算する
#
# 目的：
# - 不利局面を "フェイズ追加" ではなく「立場」として表現（破綻しにくい）
# - 絶対評価に寄りすぎない：短期EWMAと長期EWMAの差（流れ）も使う
#
# self_cp は「手番側（いま指す側）視点」の cp を想定（USIの通常動作）
# ---------------------------------------------------------
ST_EWMA_FAST_ALPHA = float(os.environ.get("TASO_ST_EWMA_FAST_ALPHA", "0.35"))
ST_EWMA_SLOW_ALPHA = float(os.environ.get("TASO_ST_EWMA_SLOW_ALPHA", "0.08"))

# 立場判定の主役は「流れ」(fast - slow)。絶対値は補助として弱めに使う。
ST_REL_ENTER = int(os.environ.get("TASO_ST_REL_ENTER", "180"))
ST_REL_EXIT  = int(os.environ.get("TASO_ST_REL_EXIT",  "90"))

ST_ABS_ENTER = int(os.environ.get("TASO_ST_ABS_ENTER", "450"))
ST_ABS_EXIT  = int(os.environ.get("TASO_ST_ABS_EXIT",  "250"))


# PVContactSoon の先読み手数（ply）
GP_PV_PLY = int(os.environ.get("TASO_GP_PV_PLY", "6"))

MODE_PLAY = "PLAY"
MODE_WATCH = "WATCH"
MODE_ANALYZE = "ANALYZE"
DEFAULT_MODE = os.environ.get("TASO_MODE", MODE_WATCH).upper()
if DEFAULT_MODE not in (MODE_PLAY, MODE_WATCH, MODE_ANALYZE):
    DEFAULT_MODE = MODE_WATCH

# =========================
# IO
# =========================
def out(s: str) -> None:
    try:
        sys.stdout.write(s + "\n")
        sys.stdout.flush()
    except BrokenPipeError:
        raise SystemExit(0)

def info(s: str) -> None:
    if SHOW:
        out("info string " + s)

def dbg(s: str) -> None:
    if DEBUG:
        try:
            sys.stderr.write("[TASO] " + s + "\n")
            sys.stderr.flush()
        except Exception:
            pass

# =========================
# Stdin Reader (go中 stop/quit 即応)
# =========================
class StdinReader:
    def __init__(self) -> None:
        self.q: queue.Queue[str] = queue.Queue()
        self.alive = True
        self.t = threading.Thread(target=self._run, daemon=True)
        self.t.start()

    def _run(self) -> None:
        try:
            for raw in sys.stdin:
                line = raw.strip()
                if not line:
                    continue
                self.q.put(line)
            self.alive = False
        except Exception:
            self.alive = False

    def get(self, timeout: Optional[float] = None) -> Optional[str]:
        try:
            return self.q.get(timeout=timeout)
        except queue.Empty:
            return None

    def get_nowait(self) -> Optional[str]:
        try:
            return self.q.get_nowait()
        except queue.Empty:
            return None

# =========================
# Engine Wrapper
# =========================
class Engine:
    def __init__(self):
        if not os.path.isfile(ENGINE_PATH_ABS):
            raise FileNotFoundError(f"Engine not found: {ENGINE_PATH_ABS}")

        self.p = subprocess.Popen(
            ENGINE_CMD,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            bufsize=1,
            cwd=SCRIPT_DIR,  # ★重要：eval/ book の相対パスを安定
        )
        self.q: queue.Queue[str] = queue.Queue()
        self.alive = True
        threading.Thread(target=self._reader, daemon=True).start()

    def _reader(self):
        assert self.p.stdout is not None
        for line in self.p.stdout:
            self.q.put(line.rstrip("\n"))
        self.alive = False

    def send(self, s: str) -> None:
        if self.p.stdin is None:
            return
        try:
            self.p.stdin.write(s + "\n")
            self.p.stdin.flush()
        except Exception:
            self.alive = False

    def recv(self, timeout: float = READ_TIMEOUT) -> Optional[str]:
        try:
            return self.q.get(timeout=timeout)
        except queue.Empty:
            return None

    def drain(self, limit: int = 200000) -> int:
        n = 0
        while n < limit:
            try:
                _ = self.q.get_nowait()
                n += 1
            except queue.Empty:
                break
        return n

    def close(self) -> None:
        try:
            self.send("quit")
        except Exception:
            pass
        try:
            self.p.terminate()
        except Exception:
            pass

# =========================
# Parsing helpers
# =========================
def _try_int(x: str) -> Optional[int]:
    try:
        return int(x)
    except Exception:
        return None

def parse_mate_token(tok: Optional[str]) -> Optional[int]:
    if tok is None:
        return None
    if tok.startswith("+"):
        tok = tok[1:]
    return _try_int(tok)

def prefix_len(a: str, b: str, k: int = PREFIX_K) -> int:
    aa = a.split()
    bb = b.split()
    n = 0
    for i in range(min(k, len(aa), len(bb))):
        if aa[i] != bb[i]:
            break
        n += 1
    return n



def stability_sim(a: str, b: str, k: int = PREFIX_K) -> float:
    """Weighted PV similarity in [0,1]. Less jumpy than prefix_len/k."""
    import math
    aa = a.split()
    bb = b.split()
    if k <= 0:
        return 0.0
    num = 0.0
    den = 0.0
    for i in range(k):
        w = math.exp(-float(i) / max(0.1, STAB_TAU))
        den += w
        eq = 1.0 if (i < len(aa) and i < len(bb) and aa[i] == bb[i]) else 0.0
        num += w * eq
    v = (num / den) if den > 0 else 0.0
    return max(0.0, min(1.0, v))

@dataclass
class Cand:
    mpv: int
    move: str
    pv: str
    cp: int
    mate: Optional[int]

@dataclass
class Features:
    stability: float
    opp_diff: float
    self_risk: float
    initiative: float
    winability: float
    label: str          # 旧ラベル互換（残す）
    roles: str          # 新：役割ラベル（見やすい）
    divergence: float   # 分岐度（表示・役割判定用）

def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
    return max(lo, min(hi, x))


def disp_win(w: float) -> float:
    """表示用の winability 圧縮。
    0.5 を中心にコントラストを落として、見た目のガタつき・厳しさを軽減する。
    ロジック（ランキング/方針）側は生の winability を使う。
    """
    c = max(0.30, min(1.00, float(DISP_WIN_CONTRAST)))
    return clamp(0.5 + (w - 0.5) * c)

# =========================
# Winability v1.1（中身は維持）
# =========================
def mate_risk(d: int) -> float:
    return clamp(MATE_RISK_FLOOR + (1.0 - MATE_RISK_FLOOR) * math.exp(-float(d) / MATE_RISK_TAU))

def mate_initiative(d: int) -> float:
    return clamp(MATE_INIT_FLOOR + (1.0 - MATE_INIT_FLOOR) * math.exp(-float(d) / MATE_INIT_TAU))

def _safe_best_cp(best_cp: int) -> int:
    return 0 if abs(best_cp) >= 20000 else best_cp

def _legacy_label(winability: float, stability: float, self_risk: float, initiative: float) -> str:
    if winability >= 0.75:
        tier = "安定勝ち"
    elif winability >= 0.55:
        tier = "勝負"
    elif winability >= 0.35:
        tier = "嫌味勝負"
    else:
        tier = "逆転狙い"

    if initiative >= 0.70 and self_risk <= 0.60:
        style = "攻め"
    elif stability >= 0.60 and self_risk <= 0.60:
        style = "安定"
    elif initiative >= 0.60 and self_risk >= 0.70:
        style = "開き直り"
    else:
        style = "バランス"

    return f"{tier}/{style}"

def _roles_label(
    *,
    is_best: bool,
    stability: float,
    self_risk: float,
    initiative: float,
    divergence: float,
    phase_mode: str,
) -> str:
    """
    見やすさ優先の「役割ラベル」。
    - phase_mode（局面方針）とは別軸で、候補が担う役割を短い語で出す
    - 役割は最大2つ（読みやすさ最優先）
    """
    roles: List[str] = []

    # 1) 本線：読み筋の中心
    if is_best or stability >= 0.70:
        roles.append("本線")

    # 2) 手堅い：事故りにくい（崩れにくさ）
    if self_risk <= 0.35 and stability >= 0.30:
        roles.append("手堅い")

    # 3) 受け切り：相手の攻めを受けて形を保つ（攻めに転じない）
    if self_risk <= 0.30 and initiative <= 0.35 and divergence <= 0.50 and stability >= 0.25:
        roles.append("受け切り")

    # 4) 圧：相手に対応を強制（攻めの主導権）
    if initiative >= 0.65 and self_risk <= 0.85:
        roles.append("圧")

    # 5) 揺さぶり：分岐を大きくして判断を要求
    if divergence >= 0.60 and initiative >= 0.45:
        roles.append("揺さぶり")

    # 6) チャンス待ち：粘って機会を待つ（無理に踏み込まない）
    if phase_mode in ("DISTURB", "DESPERATE"):
        if self_risk <= 0.55 and stability >= 0.25 and initiative <= 0.55 and "揺さぶり" not in roles:
            roles.append("チャンス待ち")

    # 7) 下駄を預ける：不利側の能動的な勝負（相手に選択を迫る）
    if phase_mode == "DESPERATE":
        if initiative >= 0.65 and divergence >= 0.50 and self_risk <= 0.90:
            roles.append("下駄を預ける")

    # 8) 勝負手 / 鬼手：リスクを取る一撃
    is_gamble = (initiative >= 0.60 and self_risk >= 0.60) or (phase_mode == "DESPERATE" and divergence >= 0.50 and self_risk >= 0.55)
    if is_gamble:
        if phase_mode == "DESPERATE" and initiative >= 0.72 and divergence >= 0.65 and self_risk >= 0.72:
            roles.append("鬼手")
        else:
            roles.append("勝負手")

    # 役割が多すぎると読めないので、強い順で最大2つ
    priority = ["本線", "手堅い", "受け切り", "圧", "揺さぶり", "チャンス待ち", "下駄を預ける", "鬼手", "勝負手"]
    uniq: List[str] = []
    for p in priority:
        if p in roles and p not in uniq:
            uniq.append(p)

    # ここだけは例外：鬼手 と 勝負手 は同居させない
    if "鬼手" in uniq and "勝負手" in uniq:
        uniq = [x for x in uniq if x != "勝負手"]

    uniq = uniq[:2] if uniq else ["本線"]
    return "/".join(uniq)

def compute_features(
    cand: Cand,
    best: Cand,
    context_cands: List[Cand],
    mode_hint: str
) -> Features:
    best_cp_used = _safe_best_cp(best.cp)
    cand_cp_used = 0 if abs(cand.cp) >= 20000 else cand.cp
    delta = best_cp_used - cand_cp_used

    pv_pref = prefix_len(best.pv, cand.pv, PREFIX_K)
    stability = stability_sim(best.pv, cand.pv, PREFIX_K)
    divergence = clamp((PREFIX_K - pv_pref) / float(max(1, PREFIX_K)))

    # 相手の守りやすさ（good手の多さ）を MultiPV に引っ張られないように、上位K本だけで見る
    top_ctx = sorted(
        context_cands,
        key=lambda c: (0 if abs(c.cp) >= 20000 else c.cp),
        reverse=True,
    )
    top_ctx = top_ctx[: max(1, min(GOOD_COUNT_CAP, len(top_ctx)))]

    good = 0
    for c in top_ctx:
        ccp = 0 if abs(c.cp) >= 20000 else c.cp
        if ccp >= best_cp_used - GOOD_CP_MARGIN:
            good += 1
    good = max(1, good)

    # 0.2刻みのガタつきを抑えるため、1/good ではなく滑らかな減衰にする
    tau = max(0.5, float(GOOD_TAU))
    opp_diff = clamp(1.0 / (1.0 + (good - 1.0) / tau))

    risk = 0.2
    if cand.mate is not None and cand.mate < 0:
        risk = 1.0
    else:
        if delta >= 300:
            risk = max(risk, 0.7)
        elif delta >= 180:
            risk = max(risk, 0.5)

    mate_neg_best = None
    for c in context_cands:
        if c.mate is not None and c.mate < 0:
            d = abs(c.mate)
            if mate_neg_best is None or d < mate_neg_best:
                mate_neg_best = d
    if mate_neg_best is not None:
        risk = max(risk, mate_risk(mate_neg_best))

    self_risk = clamp(risk)

    initiative = 0.0
    if cand.mate is not None and cand.mate > 0:
        initiative = max(initiative, mate_initiative(abs(cand.mate)))

    initiative = max(initiative, clamp(1.0 / (1.0 + (good - 1.0) / tau)))

    if mode_hint in ("DISTURB", "DESPERATE"):
        initiative = clamp(initiative + 0.25 * divergence)

    win = (
        0.30 * stability +
        0.25 * opp_diff +
        0.20 * (1.0 - self_risk) +
        0.25 * initiative
    )
    winability_raw = clamp(win)
    spread = clamp(WINABILITY_SPREAD, 0.5, 1.0)
    winability = clamp(0.5 + (winability_raw - 0.5) * spread)

    legacy = _legacy_label(winability, stability, self_risk, initiative)
    roles = _roles_label(
        is_best=(cand.move == best.move),
        stability=stability,
        self_risk=self_risk,
        initiative=initiative,
        divergence=divergence,
        phase_mode=mode_hint,
    )

    return Features(stability, opp_diff, self_risk, initiative, winability, legacy, roles, divergence)

# =========================
# 勝ち筋ストーリー（Winability側）: ヒステリシス + 文言
# =========================
class WinPhaseHysteresis:
    def __init__(self) -> None:
        self.phase: str = "BALANCE"

    def update(self, w: float) -> str:
        p = self.phase

        if p == "STABLE":
            if w < PH_STABLE_EXIT:
                self.phase = "BALANCE"
        elif p == "BALANCE":
            if w >= PH_STABLE_ENTER:
                self.phase = "STABLE"
            elif w < PH_BAL_EXIT:
                self.phase = "DISTURB"
        elif p == "DISTURB":
            if w >= PH_BAL_ENTER:
                self.phase = "BALANCE"
            elif w < PH_DIST_EXIT:
                self.phase = "DESPERATE"
        else:  # DESPERATE
            if w >= PH_DIST_ENTER:
                self.phase = "DISTURB"

        return self.phase

def win_plan_text(phase: str) -> str:
    if phase == "STABLE":
        return "勝ち筋: 手堅く優勢維持（崩れにくさ重視）"
    if phase == "BALANCE":
        return "勝ち筋: 本線で積み上げ（自然に良くする）"
    if phase == "DISTURB":
        return "勝ち筋: 主導権を取りにいく（相手に対応を強制）"
    return "勝ち筋: 逆転要素を残す（揺さぶり/詰めろで勝負）"

# =========================
# --- Shogi board: USI move -> 簡易KIF / 指標用 ---
# =========================
FILES_FW = "０１２３４５６７８９"  # index 1..9
RANK_KANJI = ["", "一", "二", "三", "四", "五", "六", "七", "八", "九"]

PIECE_JP = {
    "P": "歩", "L": "香", "N": "桂", "S": "銀", "G": "金", "B": "角", "R": "飛", "K": "玉",
    "+P": "と", "+L": "成香", "+N": "成桂", "+S": "成銀", "+B": "馬", "+R": "龍",
}

def _sq_to_xy(sq: str) -> Optional[Tuple[int, int]]:
    if len(sq) != 2:
        return None
    f = _try_int(sq[0])
    r = ord(sq[1]) - ord("a") + 1
    if f is None or not (1 <= f <= 9) or not (1 <= r <= 9):
        return None
    return (f, r)

def _xy_to_kif(f: int, r: int) -> str:
    return f"{FILES_FW[f]}{RANK_KANJI[r]}"

def _unpromote(p: str) -> str:
    return p[1:] if p.startswith("+") else p

def _promote(p: str) -> str:
    if p.startswith("+"):
        return p
    if p in ("P", "L", "N", "S", "B", "R"):
        return "+" + p
    return p

def _parse_sfen_board(board_sfen: str) -> List[List[Optional[Tuple[str, str]]]]:
    ranks = board_sfen.split("/")
    board: List[List[Optional[Tuple[str, str]]]] = [[None for _ in range(10)] for _ in range(10)]
    if len(ranks) != 9:
        return board

    for r_idx, row in enumerate(ranks, start=1):
        f = 1
        i = 0
        while i < len(row) and f <= 9:
            ch = row[i]
            if ch.isdigit():
                f += int(ch)
                i += 1
                continue
            promo = False
            if ch == "+":
                promo = True
                i += 1
                if i >= len(row):
                    break
                ch = row[i]

            side = "b" if ch.isupper() else "w"
            pc = ch.upper()
            piece = ("+" + pc) if promo else pc
            board[r_idx][f] = (side, piece)
            f += 1
            i += 1

    return board

def _init_startpos_board() -> List[List[Optional[Tuple[str, str]]]]:
    sfen = "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL"
    return _parse_sfen_board(sfen)

def _clone_board(board: List[List[Optional[Tuple[str, str]]]]) -> List[List[Optional[Tuple[str, str]]]]:
    return [row[:] for row in board]

def _side_to_move_from_position(base_position: str) -> str:
    toks = base_position.split()
    if not toks or toks[0] != "position":
        return "b"
    i = 1
    if i < len(toks) and toks[i] == "startpos":
        if "moves" in toks:
            mc = len(toks) - (toks.index("moves") + 1)
            return "b" if mc % 2 == 0 else "w"
        return "b"
    if i < len(toks) and toks[i] == "sfen":
        # position sfen <board> <side> <hand> <move#> [moves ...]
        if i + 2 < len(toks):
            return "b" if toks[i + 2] == "b" else "w"
    return "b"

def _board_from_position(base_position: str) -> Tuple[List[List[Optional[Tuple[str, str]]]], str]:
    board = _init_startpos_board()
    side = "b"
    toks = base_position.split()
    if not toks or toks[0] != "position":
        return board, side

    i = 1
    if i < len(toks) and toks[i] == "startpos":
        board = _init_startpos_board()
        side = "b"
    elif i < len(toks) and toks[i] == "sfen":
        if i + 4 < len(toks):
            board_sfen = toks[i + 1]
            side_sfen = toks[i + 2]
            board = _parse_sfen_board(board_sfen)
            side = "b" if side_sfen == "b" else "w"
    else:
        return board, side

    if "moves" in toks:
        m_idx = toks.index("moves") + 1
        seq = toks[m_idx:]
        for mv in seq:
            board, _, _ = _apply_usi_move(board, side, mv)
            side = "w" if side == "b" else "b"

    return board, side

def _apply_usi_move(
    board: List[List[Optional[Tuple[str, str]]]],
    side_to_move: str,
    move: str
) -> Tuple[List[List[Optional[Tuple[str, str]]]], str, bool]:
    """
    Apply move to board (軽量・擬似合法)。capture検出あり。
    Returns (new_board, moved_piece_code_after, captured?)
    """
    b2 = _clone_board(board)

    # drop: "P*7f"
    if "*" in move:
        pc = move[0].upper()
        dst = move.split("*", 1)[1]
        xy = _sq_to_xy(dst)
        piece = pc
        if xy:
            f, r = xy
            b2[r][f] = (side_to_move, piece)
        return b2, piece, False

    prom = move.endswith("+")
    core = move[:-1] if prom else move
    if len(core) != 4:
        return b2, "P", False

    src = core[:2]
    dst = core[2:]
    sxy = _sq_to_xy(src)
    dxy = _sq_to_xy(dst)
    if not sxy or not dxy:
        return b2, "P", False

    sf, sr = sxy
    df, dr = dxy

    sp = b2[sr][sf]
    moved = sp[1] if sp else "P"

    captured = False
    dp = b2[dr][df]
    if dp is not None and dp[0] != side_to_move:
        captured = True

    b2[sr][sf] = None
    moved_after = _promote(moved) if prom else moved
    b2[dr][df] = (side_to_move, moved_after)
    return b2, moved_after, captured

def usi_move_to_kif(base_position: str, usi_move: str) -> str:
    if not SHOW_KIF:
        return usi_move

    board, side = _board_from_position(base_position)
    side_to_move = side

    # drop
    if "*" in usi_move:
        pc = usi_move[0].upper()
        dst = usi_move.split("*", 1)[1]
        dxy = _sq_to_xy(dst)
        if not dxy:
            return usi_move
        df, dr = dxy
        piece_jp = PIECE_JP.get(pc, pc)
        return f"{_xy_to_kif(df, dr)}{piece_jp}打"

    prom = usi_move.endswith("+")
    core = usi_move[:-1] if prom else usi_move
    if len(core) != 4:
        return usi_move
    dst = core[2:]
    dxy = _sq_to_xy(dst)
    if not dxy:
        return usi_move

    # apply once to learn moved piece
    _, moved_piece, _ = _apply_usi_move(board, side_to_move, usi_move)

    df, dr = dxy
    piece_jp = PIECE_JP.get(moved_piece, PIECE_JP.get(_unpromote(moved_piece), moved_piece))
    suffix = "成" if prom else ""
    return f"{_xy_to_kif(df, dr)}{piece_jp}{suffix}"

# =========================
# ゲームフェイズ指標
# =========================
def _in_bounds(f: int, r: int) -> bool:
    return 1 <= f <= 9 and 1 <= r <= 9

def _dir(side: str) -> int:
    return -1 if side == "b" else 1

def _gold_moves(side: str) -> List[Tuple[int, int]]:
    d = _dir(side)
    return [(0, d), (-1, d), (1, d), (-1, 0), (1, 0), (0, -d)]

def _silver_moves(side: str) -> List[Tuple[int, int]]:
    d = _dir(side)
    return [(0, d), (-1, d), (1, d), (-1, -d), (1, -d)]

def _knight_moves(side: str) -> List[Tuple[int, int]]:
    d = _dir(side)
    return [(-1, 2*d), (1, 2*d)]

def _king_moves() -> List[Tuple[int, int]]:
    return [(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]

def _attack_squares(board: List[List[Optional[Tuple[str,str]]]], side: str, f: int, r: int, piece: str) -> List[Tuple[int,int]]:
    # piece is like 'P','+R' etc
    res: List[Tuple[int,int]] = []
    d = _dir(side)

    def add(df: int, dr: int) -> None:
        nf, nr = f + df, r + dr
        if _in_bounds(nf, nr):
            res.append((nf, nr))

    def slide(df: int, dr: int) -> None:
        nf, nr = f + df, r + dr
        while _in_bounds(nf, nr):
            res.append((nf, nr))
            if board[nr][nf] is not None:
                break
            nf += df
            nr += dr

    p = piece
    if p in ("P",):
        add(0, d)
    elif p in ("L",):
        slide(0, d)
    elif p in ("N",):
        for df, dr in _knight_moves(side):
            add(df, dr)
    elif p in ("S",):
        for df, dr in _silver_moves(side):
            add(df, dr)
    elif p in ("G",):
        for df, dr in _gold_moves(side):
            add(df, dr)
    elif p in ("K",):
        for df, dr in _king_moves():
            add(df, dr)
    elif p in ("B",):
        for df, dr in [(-1,-1),(1,-1),(-1,1),(1,1)]:
            slide(df, dr)
    elif p in ("R",):
        for df, dr in [(0,-1),(0,1),(-1,0),(1,0)]:
            slide(df, dr)
    elif p in ("+P","+L","+N","+S"):
        for df, dr in _gold_moves(side):
            add(df, dr)
    elif p == "+B":
        for df, dr in [(-1,-1),(1,-1),(-1,1),(1,1)]:
            slide(df, dr)
        for df, dr in [(0,-1),(0,1),(-1,0),(1,0)]:
            add(df, dr)
    elif p == "+R":
        for df, dr in [(0,-1),(0,1),(-1,0),(1,0)]:
            slide(df, dr)
        for df, dr in [(-1,-1),(1,-1),(-1,1),(1,1)]:
            add(df, dr)
    else:
        # unknown -> none
        pass

    return res

def contact_soon_count(board: List[List[Optional[Tuple[str,str]]]]) -> int:
    """
    次手で取れる駒（=接触点）の多さを、両者合計で数える。
    厳密な合法手ではなく「擬似攻撃」で十分（フェイズ用途）。
    """
    targets_b: Set[Tuple[int,int]] = set()
    targets_w: Set[Tuple[int,int]] = set()

    for r in range(1, 10):
        for f in range(1, 10):
            cell = board[r][f]
            if cell is None:
                continue
            side, piece = cell
            att = _attack_squares(board, side, f, r, piece)
            for (af, ar) in att:
                dst = board[ar][af]
                if dst is None:
                    continue
                if dst[0] == side:
                    continue
                if side == "b":
                    targets_b.add((af, ar))
                else:
                    targets_w.add((af, ar))

    return len(targets_b) + len(targets_w)

def _attack_readiness_side(board: List[List[Optional[Tuple[str,str]]]], side: str) -> float:
    """
    攻撃体制の整い具合（0..1）。
    - 駒の前進（主力/小駒の展開）
    - 主要ラインの開通（飛車・角）
    - 敵陣侵入（相手陣3段目以内）
    """
    # home ranks: black 7-9, white 1-3 (SFEN rank index 1..9)
    minor_adv = 0.0
    minor_total = 0.0
    camp = 0.0
    camp_total = 0.0

    def adv_amount(r: int) -> int:
        # black: smaller r is advanced. white: larger r is advanced.
        return max(0, (7 - r)) if side == "b" else max(0, (r - 3))

    for r in range(1, 10):
        for f in range(1, 10):
            cell = board[r][f]
            if cell is None or cell[0] != side:
                continue
            piece = cell[1]
            if piece in ("K",):
                continue

            # minor set
            if _unpromote(piece) in ("P","L","N","S","G"):
                minor_total += 1.0
                a = adv_amount(r)
                if a >= 1:
                    minor_adv += 1.0
                elif a == 0 and _unpromote(piece) == "P":
                    # 端歩/飛車先などは0でも微弱な準備とみなせるが、ここでは増やさない
                    pass

            # camp presence (deep)
            camp_total += 1.0
            if side == "b":
                if r <= 3:
                    camp += 1.0
            else:
                if r >= 7:
                    camp += 1.0

    minor = (minor_adv / minor_total) if minor_total > 0 else 0.0
    camp_ratio = (camp / camp_total) if camp_total > 0 else 0.0

    # rook file pawn advanced or exchanged
    open_rook = 0.0
    if side == "b":
        rook_file = 2
        pawn_start_r = 7
    else:
        rook_file = 8
        pawn_start_r = 3

    pawn_found = False
    for r in range(1, 10):
        cell = board[r][rook_file]
        if cell and cell[0] == side and _unpromote(cell[1]) == "P":
            pawn_found = True
            if r != pawn_start_r:
                open_rook = 1.0
            break
    if not pawn_found:
        # already exchanged/advanced beyond detection
        open_rook = 1.0

    # bishop diagonal openness (very rough): squares adjacent from initial bishop squares are empty
    open_bishop = 0.0
    bishop_sq = (8, 8) if side == "b" else (2, 2)  # startpos bishop: black 8h(rank8), white 2b(rank2)
    bf, br = bishop_sq
    if _in_bounds(bf, br):
        cell = board[br][bf]
        if cell and cell[0] == side and _unpromote(cell[1]) == "B":
            # check one step diagonals towards center
            steps = [(-1,-1),(1,-1),(-1,1),(1,1)]
            open_cnt = 0
            for df, dr in steps:
                nf, nr = bf + df, br + dr
                if _in_bounds(nf, nr) and board[nr][nf] is None:
                    open_cnt += 1
            open_bishop = clamp(open_cnt / 4.0)

    # combine
    readiness = 0.45 * minor + 0.30 * max(open_rook, open_bishop) + 0.25 * camp_ratio
    return clamp(readiness)

def attack_readiness(board: List[List[Optional[Tuple[str,str]]]], side_to_move: str) -> float:
    """
    両者の準備度のうち「高い方」を採用（緊張は片側の仕掛け準備で上がる）。
    """
    rb = _attack_readiness_side(board, "b")
    rw = _attack_readiness_side(board, "w")
    return max(rb, rw)

def _norm_csc(csc: int) -> float:
    # 0,1,2... が序盤で過敏にならないように指数で丸める
    return clamp(1.0 - math.exp(-float(max(0, csc)) / 4.0))

def pv_contact_soon(base_position: str, pv_line: str, ply: int = GP_PV_PLY) -> float:
    """
    PV内で「接触が近い」度合い（0..1）。
    - 早い捕獲ほど高い
    - 捕獲が無くても、捕獲可能状態が早く出るなら中くらい
    """
    if not base_position.startswith("position") or not pv_line:
        return 0.0

    board, side = _board_from_position(base_position)
    moves = pv_line.split()
    if not moves:
        return 0.0

    t_capture: Optional[int] = None
    t_contact: Optional[int] = None

    cur_board = board
    cur_side = side

    for i, mv in enumerate(moves[:ply], start=1):
        cur_board, _, captured = _apply_usi_move(cur_board, cur_side, mv)
        cur_side = "w" if cur_side == "b" else "b"

        if captured and t_capture is None:
            t_capture = i

        # contact check
        if t_contact is None:
            csc = contact_soon_count(cur_board)
            if csc >= 1:
                t_contact = i

        if t_capture is not None and t_capture <= 2:
            break

    score_cap = 0.0
    if t_capture is not None:
        score_cap = clamp(math.exp(-float(t_capture - 1) / 1.6))
    score_con = 0.0
    if t_contact is not None:
        score_con = clamp(math.exp(-float(t_contact - 1) / 2.4))

    return clamp(max(score_cap, 0.85 * score_con))

@dataclass
class GamePhaseMetrics:
    csc: int
    csc_n: float
    ar: float
    pvcs: float
    engage: float

class GamePhaseState:
    """
    BUILD -> PROBE -> TENSION -> CLASH -> CONVERT -> FINISH
    - raw指標をEWMAで平滑化
    - ヒステリシス境界で安定化
    - ショック遷移（急変時は上方向飛び越え）
    - 鎮静化は戻れるが、原則1段ずつ（ブレ防止）
    """
    ORDER = ["BUILD", "PROBE", "TENSION", "CLASH", "CONVERT", "FINISH"]

    def __init__(self) -> None:
        self.phase: str = "BUILD"
        self.ew_csc: float = 0.0
        self.ew_ar: float = 0.0
        self.ew_pvcs: float = 0.0
        self.ew_eng: float = 0.0

    def _ewma(self, prev: float, x: float) -> float:
        a = clamp(GP_EWMA_ALPHA, 0.05, 0.90)
        return a * x + (1.0 - a) * prev

    def _desired_base(self, eng: float) -> str:
        # enter thresholds
        if eng >= GP_CLASH_ENTER:
            return "CLASH"
        if eng >= GP_TENS_ENTER:
            return "TENSION"
        if eng >= GP_PROBE_ENTER:
            return "PROBE"
        return "BUILD"

    def _hys_step(self, current: str, eng: float) -> str:
        # exit thresholds
        probe_exit = GP_PROBE_ENTER - GP_HYS_GAP
        tens_exit  = GP_TENS_ENTER - GP_HYS_GAP
        clash_exit = GP_CLASH_ENTER - GP_HYS_GAP

        if current == "BUILD":
            if eng >= GP_PROBE_ENTER:
                return "PROBE"
            return "BUILD"

        if current == "PROBE":
            if eng >= GP_TENS_ENTER:
                return "TENSION"
            if eng < probe_exit:
                return "BUILD"
            return "PROBE"

        if current == "TENSION":
            if eng >= GP_CLASH_ENTER:
                return "CLASH"
            if eng < tens_exit:
                return "PROBE"
            return "TENSION"

        if current == "CLASH":
            if eng < clash_exit:
                return "TENSION"
            return "CLASH"

        return current

    def update(
        self,
        raw: GamePhaseMetrics,
        best_cp_abs: int,
        has_mate: bool
    ) -> str:
        # 1) EWMA
        self.ew_csc  = self._ewma(self.ew_csc, float(raw.csc))
        self.ew_ar   = self._ewma(self.ew_ar, raw.ar)
        self.ew_pvcs = self._ewma(self.ew_pvcs, raw.pvcs)
        self.ew_eng  = self._ewma(self.ew_eng, raw.engage)

        # 2) ショック（上方向飛び越え）
        if has_mate or best_cp_abs >= GP_FINISH_CP_ENTER:
            self.phase = "FINISH"
            return self.phase

        if best_cp_abs >= GP_CONVERT_CP_ENTER and self.ew_eng >= 0.30:
            # 勝勢運用に飛ぶ（ただし終盤判定は上で先に吸う）
            if self.phase in ("BUILD","PROBE","TENSION","CLASH","CONVERT"):
                self.phase = "CONVERT"
                return self.phase

        if self.ew_pvcs >= GP_SHOCK_PVCS or int(round(self.ew_csc)) >= GP_SHOCK_CSC:
            # 急戦の仕掛け/激化
            if self.phase in ("BUILD","PROBE","TENSION"):
                self.phase = "CLASH"
                return self.phase

        # 3) 退場（FINISH/CONVERTの解除）—落ち着いたら戻れる
        if self.phase == "FINISH":
            if (not has_mate) and best_cp_abs < GP_FINISH_CP_EXIT:
                self.phase = "CONVERT" if best_cp_abs >= GP_CONVERT_CP_ENTER else "CLASH"
            return self.phase

        if self.phase == "CONVERT":
            if best_cp_abs < GP_CONVERT_CP_EXIT:
                # 接触が薄いならTENSIONへ、濃いならCLASHへ
                self.phase = "CLASH" if self.ew_eng >= (GP_CLASH_ENTER - GP_HYS_GAP) else "TENSION"
            return self.phase

        # 4) BUILD〜CLASH（ヒステリシス）
        next_phase = self._hys_step(self.phase, self.ew_eng)

        # 5) 鎮静化は原則1段ずつ（ブレ抑制）
        cur_idx = self.ORDER.index(self.phase)
        nxt_idx = self.ORDER.index(next_phase)
        if nxt_idx < cur_idx - 1:
            next_phase = self.ORDER[cur_idx - 1]

        self.phase = next_phase
        return self.phase


# ---------------------------------------------------------
# Polarity / Stance (Advantage, Even, Disadvantage)
# ---------------------------------------------------------
ST_AHEAD  = "AHEAD"
ST_EVEN   = "EVEN"
ST_BEHIND = "BEHIND"

class StanceState:
    """局面の「立場」を、短期/長期EWMAで滑らかに追う。

    - fast: 直近の評価（いまの気配）
    - slow: ちょい長めの平均（将棋の基調）
    - rel = fast - slow: 「流れ」（戦型の癖を相殺しやすい）
    """
    def __init__(self) -> None:
        self.fast: Optional[float] = None
        self.slow: Optional[float] = None
        self.state: str = ST_EVEN

    def update(self, self_cp: int) -> str:
        x = float(self_cp)

        if self.fast is None:
            self.fast = x
            self.slow = x
            self.state = ST_EVEN
            return self.state

        assert self.slow is not None
        self.fast = (1.0 - ST_EWMA_FAST_ALPHA) * self.fast + ST_EWMA_FAST_ALPHA * x
        self.slow = (1.0 - ST_EWMA_SLOW_ALPHA) * self.slow + ST_EWMA_SLOW_ALPHA * x

        rel = self.fast - self.slow

        if self.state == ST_AHEAD:
            if rel < ST_REL_EXIT and self.fast < ST_ABS_EXIT:
                self.state = ST_EVEN

        elif self.state == ST_BEHIND:
            if rel > -ST_REL_EXIT and self.fast > -ST_ABS_EXIT:
                self.state = ST_EVEN

        else:  # EVEN
            if rel >= ST_REL_ENTER or self.fast >= ST_ABS_ENTER:
                self.state = ST_AHEAD
            elif rel <= -ST_REL_ENTER or self.fast <= -ST_ABS_ENTER:
                self.state = ST_BEHIND

        return self.state


# =========================
# IntentState (plan) lifecycle
# - current_plan を「筋」として保持し、例外条件のみで切替を正当化
# - plan は bestmove を歪めない（候補の並び/説明のみに影響）
# =========================

# plan（意図）の種類（固定）
PL_SHAPE    = "SHAPE"     # 形づくり/整備
PL_MAINLINE = "MAINLINE"  # 本線継続
PL_PRESSURE = "PRESSURE"  # プレッシャー（圧）
PL_SHAKE    = "SHAKE"     # 揺さぶり
PL_SURVIVE  = "SURVIVE"   # 粘り（チャンス待ち）
PL_GAMBLE   = "GAMBLE"    # 勝負手（下駄を預ける）
PL_CONVERT  = "CONVERT"   # 勝勢運用（収束）
PL_FINISH   = "FINISH"    # 寄せ切り

PLAN_NAMES_JP = {
    PL_SHAPE:    "形づくり",
    PL_MAINLINE: "本線継続",
    PL_PRESSURE: "プレッシャー",
    PL_SHAKE:    "揺さぶり",
    PL_SURVIVE:  "粘り（チャンス待ち）",
    PL_GAMBLE:   "勝負手（下駄）",
    PL_CONVERT:  "勝勢運用",
    PL_FINISH:   "寄せ切り",
}

# ユーザー棋風（候補の並び替えの傾向にだけ反映）
STYLE_BALANCE = "BALANCE"
STYLE_ATTACK  = "ATTACK"
STYLE_DEFENSE = "DEFENSE"
USER_STYLE = os.environ.get("TASO_STYLE", STYLE_BALANCE).upper()
if USER_STYLE not in (STYLE_BALANCE, STYLE_ATTACK, STYLE_DEFENSE):
    USER_STYLE = STYLE_BALANCE

# planの粘着（局面が同じ go では基本維持）
PLAN_LOCK_PLIES = int(os.environ.get("TASO_PLAN_LOCK_PLIES", "2"))  # 何手ぶんは切替を抑制
PLAN_CP_JUMP_OK = float(os.environ.get("TASO_PLAN_CP_JUMP_OK", "260"))  # self_cp(EWMA fast)のジャンプで切替OK
PLAN_PVCS_JUMP_OK = float(os.environ.get("TASO_PLAN_PVCS_JUMP_OK", "0.22"))  # PVContactSoon(EWMA)の増加で切替OK

def _phase_index(p: str) -> int:
    order = [GP_BUILD, GP_PROBE, GP_TENSION, GP_CLASH, GP_CONVERT, GP_FINISH]
    try:
        return order.index(p)
    except Exception:
        return 0

def _pos_signature(position_line: str) -> str:
    """同一局面判定用。moves の末尾だけを見る（軽量・安定）。"""
    if not position_line:
        return ""
    tt = position_line.split()
    if "moves" not in tt:
        return position_line
    i = tt.index("moves")
    tail = tt[max(0, len(tt) - 20):]  # 末尾20手ぶん
    head = tt[: i + 1]
    return " ".join(head + tail)

def _roles_contains(f: 'Features', key: str) -> bool:
    return key in (f.roles or "")

def _suggest_plan(
    gp_phase: str,
    stance: str,
    best_feat: 'Features',
) -> str:
    # まずフェイズ主導の強制
    if gp_phase == GP_FINISH:
        return PL_FINISH
    if gp_phase == GP_CONVERT and stance == ST_AHEAD:
        return PL_CONVERT

    # ロール主導（bestPVの役割から推測）
    r = best_feat.roles or ""

    if "鬼手" in r:
        return PL_FINISH if gp_phase in (GP_CLASH, GP_CONVERT, GP_FINISH) else PL_GAMBLE
    if "勝負手" in r or "下駄を預ける" in r:
        return PL_GAMBLE
    if "チャンス待ち" in r or "粘り" in r:
        return PL_SURVIVE
    if "揺さぶり" in r:
        return PL_SHAKE
    if "圧" in r:
        return PL_PRESSURE
    if "手堅い" in r or "受け切り" in r:
        return PL_CONVERT if stance == ST_AHEAD else PL_SURVIVE
    # default
    if gp_phase in (GP_BUILD, GP_PROBE):
        return PL_SHAPE
    if gp_phase == GP_TENSION:
        return PL_MAINLINE
    return PL_MAINLINE

def _style_bias(plan: str) -> str:
    # 棋風でほんの少しだけ寄せる（切替の最終段の微調整）
    if USER_STYLE == STYLE_ATTACK:
        if plan in (PL_SHAPE, PL_CONVERT) :
            return PL_MAINLINE
    if USER_STYLE == STYLE_DEFENSE:
        if plan in (PL_PRESSURE, PL_SHAKE, PL_GAMBLE):
            return PL_SURVIVE
    return plan

def _plan_affinity(plan: str, gp_phase: str, stance: str, f: 'Features') -> float:
    """候補の並び替え用：planに合う役割へ僅かなボーナス。"""
    r = f.roles or ""
    s = 0.0

    # 基本：役割 ↔ plan
    if plan == PL_SHAPE and ("手堅い" in r or "本線" in r):
        s += 0.10
    if plan == PL_MAINLINE and ("本線" in r):
        s += 0.12
    if plan == PL_PRESSURE and ("圧" in r):
        s += 0.14
    if plan == PL_SHAKE and ("揺さぶり" in r):
        s += 0.14
    if plan == PL_SURVIVE and ("粘り" in r or "チャンス待ち" in r):
        s += 0.14
    if plan == PL_GAMBLE and ("勝負手" in r or "下駄を預ける" in r or "鬼手" in r):
        s += 0.14
    if plan == PL_CONVERT and ("手堅い" in r or "受け切り" in r):
        s += 0.14
    if plan == PL_FINISH and ("鬼手" in r):
        s += 0.14

    # フェイズとの相性（軽く）
    if gp_phase == GP_TENSION and plan in (PL_PRESSURE, PL_MAINLINE):
        s += 0.05
    if gp_phase == GP_CLASH and plan in (PL_PRESSURE, PL_SHAKE, PL_MAINLINE):
        s += 0.05
    if gp_phase == GP_CONVERT and plan == PL_CONVERT:
        s += 0.06
    if gp_phase == GP_FINISH and plan == PL_FINISH:
        s += 0.08

    # スタンス補正（軽く）
    if stance == ST_BEHIND and plan in (PL_SURVIVE, PL_GAMBLE, PL_SHAKE):
        s += 0.04
    if stance == ST_AHEAD and plan in (PL_CONVERT, PL_SHAPE):
        s += 0.04

    return s

class IntentState:
    def __init__(self) -> None:
        self.current_plan: str = PL_MAINLINE
        self.lock_left: int = 0
        self.last_pos_sig: str = ""
        self.last_cp_fast: Optional[float] = None
        self.last_pvcs: Optional[float] = None
        self.last_phase: Optional[str] = None

    def reset(self) -> None:
        self.current_plan = PL_MAINLINE
        self.lock_left = 0
        self.last_pos_sig = ""
        self.last_cp_fast = None
        self.last_pvcs = None
        self.last_phase = None

    def update(
        self,
        *,
        position_line: str,
        gp_phase: str,
        stance: str,
        cp_fast: float,
        pvcs_ew: float,
        shock: bool,
        best_feat: 'Features',
    ) -> Tuple[str, str]:
        """
        Returns (intent_line, reason)
        - intent_line: 表示用（継続/切替理由つき）
        - reason: 切替理由（継続なら空）
        """
        pos_sig = _pos_signature(position_line)
        pos_changed = (pos_sig != self.last_pos_sig)

        # 初期化（最初の局面）
        if not self.last_pos_sig:
            self.last_pos_sig = pos_sig
            self.last_cp_fast = cp_fast
            self.last_pvcs = pvcs_ew
            self.last_phase = gp_phase
            sug = _style_bias(_suggest_plan(gp_phase, stance, best_feat))
            self.current_plan = sug
            self.lock_left = max(0, PLAN_LOCK_PLIES)
            return (f"意図={PLAN_NAMES_JP.get(self.current_plan, self.current_plan)}（開始）", "開始")

        # lockの減衰は「局面が進んだ時だけ」
        if pos_changed and self.lock_left > 0:
            self.lock_left -= 1

        # 例外条件（切替の正当化）
        reason = ""
        if shock:
            reason = "ショック遷移"
        elif self.last_cp_fast is not None and abs(cp_fast - self.last_cp_fast) >= PLAN_CP_JUMP_OK:
            reason = "評価急変"
        elif self.last_pvcs is not None and (pvcs_ew - self.last_pvcs) >= PLAN_PVCS_JUMP_OK:
            reason = "戦場が開いた"
        else:
            # フェイズが2段以上進む（小ショック）
            if self.last_phase is not None and (_phase_index(gp_phase) - _phase_index(self.last_phase)) >= 2:
                reason = "急展開"

        # 提案plan
        sug = _style_bias(_suggest_plan(gp_phase, stance, best_feat))

        switched = False
        if sug != self.current_plan:
            # 原則：lock中は維持。ただし例外理由があれば切替OK
            if reason and (pos_changed or shock):
                self.current_plan = sug
                self.lock_left = max(0, PLAN_LOCK_PLIES)
                switched = True
            # lockが切れていて局面が進んだなら自然切替
            elif pos_changed and self.lock_left <= 0 and gp_phase != GP_BUILD:
                self.current_plan = sug
                self.lock_left = max(0, PLAN_LOCK_PLIES)
                reason = "自然切替"
                switched = True

        # 状態更新
        if pos_changed:
            self.last_pos_sig = pos_sig
        self.last_cp_fast = cp_fast
        self.last_pvcs = pvcs_ew
        self.last_phase = gp_phase

        if switched:
            return (f"意図={PLAN_NAMES_JP.get(self.current_plan, self.current_plan)}（切替:{reason}）", reason)
        return (f"意図={PLAN_NAMES_JP.get(self.current_plan, self.current_plan)}（継続）", "")

def stance_vocab_for_display(gp_phase: str, stance: str) -> str:
    """phase × stance で、ユーザーに刺さる短い語彙を返す。"""
    if stance == ST_AHEAD:
        if gp_phase in ("CONVERT", "FINISH"):
            return "勝ち筋運用"
        return "押せる"
    if stance == ST_BEHIND:
        if gp_phase in ("CONVERT", "FINISH"):
            return "凌ぎ勝負"
        if gp_phase == "CLASH":
            return "苦しい（粘り）"
        return "我慢"
    return "互角"

def game_phase_text(phase: str) -> str:
    # 表示名は人間向け（短く）
    if phase == "BUILD":
        return "整備"
    if phase == "PROBE":
        return "探り"
    if phase == "TENSION":
        return "前夜"
    if phase == "CLASH":
        return "衝突"
    if phase == "CONVERT":
        return "勝勢運用"
    return "終盤"

# =========================
# Game phase vocab (TENSION語彙固定) + phase×roles 表示辞書
# =========================

# 局面フェイズごとの「方針」テキスト。
# ここは“手の流れ”を支える脚本側。評価値や候補が多少揺れても、言葉はブレにくい方が良い。
GAME_PHASE_PLAN_TEXT: Dict[str, str] = {
    "BUILD":   "方針: 守りと形作り（駒組み・玉形・働きを整える）",
    "PROBE":   "方針: 探りと含み（小さく触れて相手の反応を見る）",
    # ★TENSION: 「詰めろ級」など終盤語彙は使わない（まだ“接触前夜”なので不自然）
    "TENSION": "方針: 一触即発（牽制しつつ、仕掛けの選択肢を準備する）",
    "CLASH":   "方針: ぶつけ合い開始（主導権・速度・駒得を取りにいく）",
    "CONVERT": "方針: 勝勢運用（リスクを絞って勝ち筋を細らせない）",
    "FINISH":  "方針: 終盤（詰み/受け切り/寄せの速度を最優先）",
}

def game_phase_plan_text(phase: str) -> str:
    return GAME_PHASE_PLAN_TEXT.get(phase, "方針: -")

# ---- phase×roles 表示辞書 ----
# 役割ラベルは「短く」「誤解が少なく」「フェイズに合う語」を優先する。
# 例: TENSION で「詰めろ級」は不自然 → 「牽制」「踏み込み」などに置換。
ROLE_VOCAB_BY_GPHASE: Dict[str, Dict[str, str]] = {
    "BUILD": {
        "本線": "本線",
        "手堅い": "手堅い",
        "圧": "主張",
        "揺さぶり": "工夫",
        "粘り": "粘り",
        "勝負手": "勝負手",
        "チャンス待ち": "チャンス待ち",
        "下駄を預ける": "下駄を預ける",
        "受け切り": "受け切り",
        "鬼手": "鬼手",
    },
    "PROBE": {
        "本線": "本線",
        "手堅い": "手堅い",
        "圧": "牽制",
        "揺さぶり": "探り",
        "粘り": "粘り",
        "勝負手": "勝負手",
        "チャンス待ち": "チャンス待ち",
        "下駄を預ける": "下駄を預ける",
        "受け切り": "受け切り",
        "鬼手": "鬼手",
    },
    "TENSION": {
        "本線": "本線",
        "手堅い": "手堅い",
        # ★ここが今回の固定点（詰めろ語彙は排除）
        "圧": "牽制",
        "揺さぶり": "含み",
        "粘り": "待機",
        "勝負手": "踏み込み",
        "チャンス待ち": "チャンス待ち",
        "下駄を預ける": "下駄を預ける",
        "受け切り": "受け切り",
        # 鬼手は終盤語感が強いので、TENSIONでは弱める（でも表示は残す）
        "鬼手": "奇襲",
    },
    "CLASH": {
        "本線": "本線",
        "手堅い": "手堅い",
        "圧": "攻め圧",
        "揺さぶり": "変化",
        "粘り": "粘り",
        "勝負手": "勝負手",
        "チャンス待ち": "チャンス待ち",
        "下駄を預ける": "下駄を預ける",
        "受け切り": "受け切り",
        "鬼手": "鬼手",
    },
    "CONVERT": {
        "本線": "本線",
        "手堅い": "手堅い",
        "圧": "押し込み",
        "揺さぶり": "手順ずらし",
        "粘り": "粘り",
        "勝負手": "勝負手",
        "チャンス待ち": "チャンス待ち",
        "下駄を預ける": "下駄を預ける",
        "受け切り": "受け切り",
        "鬼手": "鬼手",
    },
    "FINISH": {
        "本線": "本線",
        "手堅い": "受け",
        "圧": "寄せ圧",
        "揺さぶり": "迫り",
        "粘り": "凌ぎ",
        "勝負手": "勝負手",
        "チャンス待ち": "チャンス待ち",
        "下駄を預ける": "下駄を預ける",
        "受け切り": "受け切り",
        "鬼手": "鬼手",
    },
}

def stylize_roles_by_gphase(roles: str, gphase: str) -> str:
    if not roles:
        return roles
    mp = ROLE_VOCAB_BY_GPHASE.get(gphase, {})
    parts = [p.strip() for p in roles.split("/") if p.strip()]
    out_parts: List[str] = []
    for p in parts:
        out_parts.append(mp.get(p, p))
    # 重複を潰す（例: 置換で同じ語が出たとき）
    uniq: List[str] = []
    for p in out_parts:
        if p not in uniq:
            uniq.append(p)
    return "/".join(uniq)


# =========================
# Candidate ranking（既存ロジック維持）
# =========================
def rank_candidates(
    cands: List[Cand],
    feats: Dict[str, Features],
    best: Cand,
    phase_mode: str
) -> List[Cand]:
    best_cp_used = _safe_best_cp(best.cp)

    def key(c: Cand) -> Tuple[float, float, float]:
        f = feats[c.move]
        ccp = 0 if abs(c.cp) >= 20000 else c.cp
        delta = float(best_cp_used - ccp)
        pref = float(prefix_len(best.pv, c.pv, PREFIX_K))

        if phase_mode == "STABLE":
            return (f.winability, -delta, pref)
        if phase_mode == "BALANCE":
            return (f.winability, -pref, -delta)
        if phase_mode == "DISTURB":
            return (0.5 * f.initiative + 0.3 * f.opp_diff + 0.2 * f.winability, -pref, -delta)
        return (0.7 * f.initiative + 0.2 * f.opp_diff + 0.1 * f.winability, -pref, -delta)

    hard_limit = DROP_SOFT_LIMIT if phase_mode in ("STABLE", "BALANCE") else DROP_DISTURB_LIMIT

    kept: List[Cand] = []
    for c in cands:
        ccp = 0 if abs(c.cp) >= 20000 else c.cp
        delta = best_cp_used - ccp
        if delta <= hard_limit:
            kept.append(c)

    if not kept:
        kept = list(cands)

    kept.sort(key=key, reverse=True)
    return kept

# =========================
# Safety check (post-move)
# =========================
def safety_check_after_move(eng: Engine, base_position: str, move: str) -> bool:
    if not base_position.startswith("position"):
        return False

    eng.drain()

    toks = base_position.split()
    if "moves" in toks:
        newpos = base_position + " " + move
    else:
        newpos = base_position + " moves " + move

    eng.send(newpos)
    eng.send(f"go movetime {SAFETY_MS}")

    unsafe = False
    t0 = time.time()
    deadline = t0 + max(
        SAFETY_DEADLINE_MIN_SEC,
        (max(1, SAFETY_MS) / 1000.0) * SAFETY_DEADLINE_FACTOR
    ) + SAFETY_DEADLINE_PAD_SEC

    got_bestmove = False
    mate_pos_hits = 0

    rto = min(READ_TIMEOUT, max(0.001, SAFETY_READ_TIMEOUT))

    while time.time() < deadline:
        o = eng.recv(rto)
        if o is None:
            continue

        if o.startswith("info") and " mate " in o:
            tt = o.split()
            if "mate" in tt:
                idx = tt.index("mate")
                m = parse_mate_token(tt[idx + 1] if idx + 1 < len(tt) else None)
                # 相手番なので mate+ は危険
                if m is not None and m > 0:
                    if m <= max(1, SAFETY_MATE_MAX):
                        unsafe = True
                    else:
                        mate_pos_hits += 1
                        if mate_pos_hits >= max(1, SAFETY_MATE_REPEAT):
                            unsafe = True

        if o.startswith("bestmove"):
            got_bestmove = True
            break

        if unsafe:
            break

    if not got_bestmove:
        eng.send("stop")
        t_stop = time.time() + SAFETY_STOP_GRACE_SEC
        while time.time() < t_stop:
            o = eng.recv(rto)
            if o is None:
                continue
            if o.startswith("bestmove"):
                break

    eng.send(base_position)  # 局面復元
    eng.drain()
    return unsafe

# =========================
# USI option collector
# =========================
def _parse_option_name(line: str) -> Optional[str]:
    if not line.startswith("option "):
        return None
    tt = line.split()
    if "name" not in tt:
        return None
    i = tt.index("name")
    if i + 1 >= len(tt):
        return None
    return tt[i + 1]

# =========================
# Main USI loop
# =========================
def main() -> None:
    eng = Engine()
    stdin = StdinReader()

    current_position = ""
    user_mode = DEFAULT_MODE
    multipv = DEFAULT_MULTIPV

    supported_opts: Set[str] = set()
    win_hys = WinPhaseHysteresis()
    game_state = GamePhaseState()
    stance_state = StanceState()
    intent_state = IntentState()

    def send_opt(name: str, value: str) -> None:
        if name in supported_opts:
            eng.send(f"setoption name {name} value {value}")

    def apply_engine_opts():
        send_opt("Threads", str(THREADS))
        send_opt("USI_Hash", str(HASH_MB))
        send_opt("MultiPV", str(multipv))

        if AUTO_DISABLE_BOOK and not os.path.isfile(BOOK_FILE):
            send_opt("USI_OwnBook", "false")

    def handle_setoption(line: str) -> bool:
        nonlocal user_mode, multipv
        toks = line.split()
        if "name" in toks:
            i = toks.index("name")
            name = toks[i + 1] if i + 1 < len(toks) else ""
            value = ""
            if "value" in toks:
                j = toks.index("value")
                value = " ".join(toks[j + 1 :]) if j + 1 < len(toks) else ""

            if name == "TASO_Mode":
                v = value.strip().upper()
                if v in (MODE_PLAY, MODE_WATCH, MODE_ANALYZE):
                    user_mode = v
                    info(f"mode set => {user_mode}")
                return True

            if name == "TASO_MultiPV":
                mv = _try_int(value.strip())
                if mv is not None and 1 <= mv <= 10:
                    multipv = mv
                    info(f"multipv set => {multipv}")
                    apply_engine_opts()
                return True

            if name == "TASO_SafetyMs":
                info("TASO_SafetyMs is fixed via env TASO_SAFETY_MS (restart required)")
                return True

        return False

    try:
        while True:
            line = stdin.get(timeout=0.1)
            if line is None:
                if not stdin.alive and stdin.q.empty():
                    break
                continue

            if line == "usi":
                supported_opts.clear()
                eng.send("usi")
                while True:
                    o = eng.recv(READ_TIMEOUT)
                    if o is None:
                        continue

                    if o.startswith("option "):
                        name = _parse_option_name(o)
                        if name:
                            supported_opts.add(name)

                    if o == "usiok":
                        out(f'option name TASO_Mode type combo default {DEFAULT_MODE} var PLAY var WATCH var ANALYZE')
                        out(f'option name TASO_MultiPV type spin default {DEFAULT_MULTIPV} min 1 max 10')
                        out(f'option name TASO_SafetyMs type spin default {SAFETY_MS} min 0 max 500')
                        out("usiok")
                        break
                    out(o)

                apply_engine_opts()
                continue

            if line.startswith("setoption"):
                if handle_setoption(line):
                    continue
                eng.send(line)
                continue

            if line == "isready":
                eng.send("isready")
                t0 = time.time()
                while True:
                    o = eng.recv(READ_TIMEOUT)
                    if o is None:
                        if time.time() - t0 > 10.0:
                            out("readyok")
                            break
                        continue
                    if o == "readyok":
                        out("readyok")
                        break
                    if o.startswith("info"):
                        out(o)
                continue

            if line == "usinewgame":
                eng.send(line)
                game_state.reset()
                stance_state.reset()
                intent_state.reset()
                continue

            if line.startswith("position"):
                current_position = line
                eng.send(line)
                continue

            if line.startswith("go"):
                eng.drain()
                apply_engine_opts()
                eng.send(line)

                cands_map: Dict[int, Cand] = {}
                best_engine_move: Optional[str] = None

                t_go = time.time()
                sent_stop = False
                already_resigned = False
                deferred: List[str] = []

                while True:
                    while True:
                        cmd = stdin.get_nowait()
                        if cmd is None:
                            break
                        if cmd == "stop":
                            eng.send("stop")
                            sent_stop = True
                        elif cmd == "ponderhit":
                            eng.send("ponderhit")
                        elif cmd == "quit":
                            eng.send("quit")
                            return
                        else:
                            deferred.append(cmd)

                    if time.time() - t_go > GO_HARD_SEC:
                        if not sent_stop:
                            eng.send("stop")
                            sent_stop = True
                            t_go = time.time() - (GO_HARD_SEC - GO_STOP_GRACE_SEC)
                        else:
                            info("⚠ go timeout: bestmove not returned -> resign")
                            out("bestmove resign")
                            already_resigned = True
                            break

                    o = eng.recv(READ_TIMEOUT)
                    if o is None:
                        continue

                    if o.startswith("info"):
                        out(o)

                        tt = o.split()
                        mpv = 1
                        if "multipv" in tt:
                            idx = tt.index("multipv")
                            m = _try_int(tt[idx + 1] if idx + 1 < len(tt) else "")
                            if m is not None:
                                mpv = m

                        cp = None
                        if "score" in tt and "cp" in tt:
                            idx = tt.index("cp")
                            cp = _try_int(tt[idx + 1] if idx + 1 < len(tt) else "")

                        mate = None
                        if "mate" in tt:
                            idx = tt.index("mate")
                            mate = parse_mate_token(tt[idx + 1] if idx + 1 < len(tt) else None)

                        if "pv" in tt:
                            i_pv = tt.index("pv")
                            if i_pv + 1 < len(tt):
                                pv = " ".join(tt[i_pv + 1 :])
                                mv = tt[i_pv + 1]

                                if cp is None:
                                    if mate is not None:
                                        cp = 30000 if mate > 0 else -30000
                                    else:
                                        cp = 0

                                cands_map[mpv] = Cand(mpv=mpv, move=mv, pv=pv, cp=cp, mate=mate)
                        continue

                    if o.startswith("bestmove"):
                        parts = o.split()
                        best_engine_move = parts[1] if len(parts) >= 2 else None
                        break

                    out(o)

                for cmd in deferred:
                    if cmd.startswith("setoption"):
                        if not handle_setoption(cmd):
                            eng.send(cmd)
                    elif cmd.startswith("position"):
                        current_position = cmd
                        eng.send(cmd)
                    elif cmd == "usinewgame":
                        eng.send(cmd)
                    elif cmd == "quit":
                        eng.send("quit")
                        return

                if already_resigned:
                    continue

                if best_engine_move is None:
                    out("bestmove resign")
                    continue

                cands = list(cands_map.values())
                if not cands:
                    out(f"bestmove {best_engine_move}")
                    continue

                best = cands_map[1] if 1 in cands_map else max(cands, key=lambda c: c.cp)

                safe_cands = [c for c in cands if not (c.mate is not None and c.mate < 0)]
                if not safe_cands:
                    safe_cands = cands

                short_mate = None
                has_mate = False
                for c in safe_cands:
                    if c.mate is not None and c.mate > 0:
                        has_mate = True
                        if short_mate is None or c.mate < short_mate[0]:
                            short_mate = (c.mate, c.move)

                # --- 勝ち筋ストーリー（Winability側） ---
                tmp_best_feat = compute_features(best, best, cands, "BALANCE")
                win_phase = win_hys.update(tmp_best_feat.winability)
                win_text = win_plan_text(win_phase)

                feats_by_move: Dict[str, Features] = {}
                for c in safe_cands:
                    feats_by_move[c.move] = compute_features(c, best, cands, win_phase)

                ranked = rank_candidates(safe_cands, feats_by_move, best, win_phase)

                # ===== bestmove（指す手）は強さ維持 =====
                chosen = best_engine_move

                for c in cands:
                    if c.move == chosen and (c.mate is not None and c.mate < 0):
                        info("⚠ bestmove shows self-mate in PV -> fallback to safest")
                        chosen = max(safe_cands, key=lambda x: x.cp).move
                        break

                if SAFETY_MS > 0 and current_position:
                    unsafe = safety_check_after_move(eng, current_position, chosen)
                    if unsafe:
                        info(f"☠ safety-check failed for {chosen} -> fallback")
                        alt = None
                        for c in ranked[: min(5, len(ranked_disp))]:
                            if c.move == chosen:
                                continue
                            if safety_check_after_move(eng, current_position, c.move):
                                continue
                            alt = c.move
                            break
                        if alt is not None:
                            chosen = alt
                        else:
                            info("☠ no alternative passed safety-check (keep chosen)")

                # ===== ゲームフェイズ（手数非依存） =====
                gp_raw = GamePhaseMetrics(0, 0.0, 0.0, 0.0, 0.0)
                gp_phase = game_state.phase
                if current_position:
                    board, _ = _board_from_position(current_position)
                    csc = contact_soon_count(board)
                    ar = attack_readiness(board, _side_to_move_from_position(current_position))
                    pvcs = pv_contact_soon(current_position, best.pv, GP_PV_PLY)
                    csc_n = _norm_csc(csc)
                    engage = clamp(0.45 * pvcs + 0.35 * csc_n + 0.20 * ar)
                    gp_raw = GamePhaseMetrics(csc, csc_n, ar, pvcs, engage)

                    best_cp_abs = abs(_safe_best_cp(best.cp))
                    gp_phase = game_state.update(gp_raw, best_cp_abs, has_mate)

                # ===== 立場（有利/互角/不利）を更新 =====
                st = stance_state.update(_safe_best_cp(best.cp))
                st_vocab = stance_vocab_for_display(gp_phase, st)

                # ===== 表示（候補提示） =====
                def fmt_move(mv: str) -> str:
                    if not current_position:
                        return mv
                    kif = usi_move_to_kif(current_position, mv)
                    if kif == mv:
                        return mv
                    return f"{kif}({mv})"

                f_best = feats_by_move.get(best.move)
                if user_mode in (MODE_PLAY, MODE_WATCH, MODE_ANALYZE) and f_best:
                    summary = (
                        f"[TASO] game={game_phase_text(gp_phase)} / 立場={st_vocab} | {game_phase_plan_text(gp_phase)} | {win_text} | {intent_line}  "
                        f"win={disp_win(f_best.winability):.2f} (cp={_safe_best_cp(best.cp):+d}) "
                        f"(eng={game_state.ew_eng:.2f} csc={int(round(game_state.ew_csc))} ar={game_state.ew_ar:.2f} pv={game_state.ew_pvcs:.2f})"
                    )
                    info(summary)

                if short_mate and short_mate[0] <= MATE_SHORT_MAX:
                    info(f"⚡ short-mate seen: mate {short_mate[0]} (pv move {fmt_move(short_mate[1])})")

                if user_mode == MODE_PLAY:
                    pass

                elif user_mode == MODE_WATCH:
                    show_n = min(3, len(ranked_disp))
                    for i in range(show_n):
                        c = ranked_disp[i]
                        f = feats_by_move[c.move]
                        mv_disp = fmt_move(c.move)
                        roles = stylize_roles_by_gphase(f.roles, gp_phase)

                        if abs(c.cp) >= 20000:
                            info(f"候補{i+1}: {mv_disp}  役割={roles}  cp=mate-only  win={disp_win(f.winability):.2f}")
                        else:
                            delta = (_safe_best_cp(best.cp) - (0 if abs(c.cp) >= 20000 else c.cp))
                            info(f"候補{i+1}: {mv_disp}  役割={roles}  cp={c.cp:+d} Δ={delta:+d}  win={disp_win(f.winability):.2f}")

                else:  # ANALYZE
                    show_n = min(max(5, multipv), len(ranked_disp))
                    for i in range(show_n):
                        c = ranked_disp[i]
                        f = feats_by_move[c.move]
                        mv_disp = fmt_move(c.move)

                        if abs(c.cp) >= 20000:
                            info(
                                f"[{i+1}] {mv_disp}  役割={stylize_roles_by_gphase(f.roles, gp_phase)}  cp=mate-only  win={disp_win(f.winability):.2f} "
                                f"(stab={f.stability:.2f} diff={f.opp_diff:.2f} risk={f.self_risk:.2f} init={f.initiative:.2f} div={f.divergence:.2f})"
                            )
                        else:
                            delta = (_safe_best_cp(best.cp) - (0 if abs(c.cp) >= 20000 else c.cp))
                            info(
                                f"[{i+1}] {mv_disp}  役割={stylize_roles_by_gphase(f.roles, gp_phase)}  cp={c.cp:+d} Δ={delta:+d}  win={disp_win(f.winability):.2f} "
                                f"(stab={f.stability:.2f} diff={f.opp_diff:.2f} risk={f.self_risk:.2f} init={f.initiative:.2f} div={f.divergence:.2f})"
                            )

                out(f"bestmove {chosen}")
                continue

            if line == "quit":
                break

            eng.send(line)

    finally:
        eng.close()

if __name__ == "__main__":
    main()

# --- IntentState（意図）を更新：筋の継続 / 切替の正当化 ---
best_feat = feats_by_move.get(best.move)
intent_line = ""
if best_feat is not None:
    intent_line, _intent_reason = intent_state.update(
        position_line=current_position,
        gp_phase=gp_phase,
        stance=stance,
        cp_fast=float(getattr(stance_state, "fast", 0.0)),
        pvcs_ew=float(getattr(game_state, "ew_pvcs", 0.0)),
        shock=bool(getattr(game_state, "shock", False)),
        best_feat=best_feat,
    )

# 表示用の候補並び（planに合う役割を少しだけ前へ。元の強さ順は崩しにくい）
if intent_line:
    ranked_disp = sorted(
        ranked,
        key=lambda c: _plan_affinity(intent_state.current_plan, gp_phase, stance, feats_by_move[c.move]),
        reverse=True,
    )
else:
    ranked_disp = ranked
