#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
NNUE USI Proxy (YaneuraOu系想定)
- bestmove は最強維持 + 安全フィルタ（強さを歪めない）
- 候補提示は Winability（人間が勝ち切れる可能性）で整形
- 頓死回避：見えてる mate負 除外 + 採用手の短時間安全確認（着手後追加探索）
- 低Winability時は Initiative 重視の「下駄を預ける」候補も提示対象
- モード：
    PLAY    : bestmove最強維持（安全のみ）、候補表示は最小
    WATCH   : bestmove最強維持（安全のみ）、候補表示＋ラベル＋ストーリー
    ANALYZE : 候補数増、Winability順提示

[Patch (executed)]
1) resign/win/0000 などの特殊bestmoveを safety_check 対象外にする（致命バグ回避）
2) 候補の保持を depth 最大優先にする（浅いinfoで上書きされるフラつき対策）
3) safety_check の stop→bestmove 同期を少しだけ堅くする（混線低減）
4) safety_check 後の position 復元は「必要時のみ」実行（余計な重さを避ける）

既存の思想・機能は削らず、より安全にした上書き版。
"""

import os
import sys
import subprocess
import threading
import queue
import time
import re
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

# =========================
# CONFIG (環境変数で上書き可)
# =========================
ENGINE_PATH = os.environ.get("TASO_ENGINE", "./YaneuraOu")
NNUE_PATH   = os.environ.get("TASO_NNUE", "nnue.bin")
ENGINE_CMD = [ENGINE_PATH, "-eval", NNUE_PATH]

THREADS = int(os.environ.get("TASO_THREADS", "6"))
HASH_MB = int(os.environ.get("TASO_HASH_MB", "4096"))

DEFAULT_MULTIPV = int(os.environ.get("TASO_MULTIPV", "3"))
PREFIX_K = int(os.environ.get("TASO_PREFIX_K", "6"))

GOOD_CP_MARGIN = int(os.environ.get("TASO_GOOD_CP_MARGIN", "150"))
DROP_SOFT_LIMIT = int(os.environ.get("TASO_DROP_SOFT_LIMIT", "200"))
DROP_DISTURB_LIMIT = int(os.environ.get("TASO_DROP_DISTURB_LIMIT", "450"))
MATE_SHORT_MAX = int(os.environ.get("TASO_SHORT_MATE_MAX", "7"))

MATE_RISK_FLOOR = float(os.environ.get("TASO_MATE_RISK_FLOOR", "0.75"))
MATE_RISK_TAU   = float(os.environ.get("TASO_MATE_RISK_TAU", "10.0"))
MATE_INIT_FLOOR = float(os.environ.get("TASO_MATE_INIT_FLOOR", "0.60"))
MATE_INIT_TAU   = float(os.environ.get("TASO_MATE_INIT_TAU", "8.0"))

SAFETY_MS = int(os.environ.get("TASO_SAFETY_MS", "40"))

SHOW = os.environ.get("TASO_SHOW", "1") == "1"
DEBUG = os.environ.get("TASO_DEBUG", "0") == "1"

READ_TIMEOUT = float(os.environ.get("TASO_READ_TIMEOUT", "0.1"))
LINE_LIMIT = int(os.environ.get("TASO_LINE_LIMIT", "200000"))

GO_HARD_SEC = float(os.environ.get("TASO_GO_HARD_SEC", "60.0"))
GO_STOP_GRACE_SEC = float(os.environ.get("TASO_GO_STOP_GRACE_SEC", "3.0"))

# safety_check deadline（比例型）
SAFETY_DEADLINE_MIN_SEC = float(os.environ.get("TASO_SAFETY_DEADLINE_MIN_SEC", "0.20"))
SAFETY_DEADLINE_FACTOR  = float(os.environ.get("TASO_SAFETY_DEADLINE_FACTOR", "3.0"))
SAFETY_DEADLINE_PAD_SEC = float(os.environ.get("TASO_SAFETY_DEADLINE_PAD_SEC", "0.05"))
SAFETY_STOP_GRACE_SEC   = float(os.environ.get("TASO_SAFETY_STOP_GRACE_SEC", "0.25"))

# --- Patch knobs (new; safe defaults) ---
SAFETY_READ_TIMEOUT = float(os.environ.get("TASO_SAFETY_READ_TIMEOUT", "0.02"))
SAFETY_MATE_MAX = int(os.environ.get("TASO_SAFETY_MATE_MAX", str(MATE_SHORT_MAX)))
SAFETY_MATE_REPEAT = int(os.environ.get("TASO_SAFETY_MATE_REPEAT", "2"))
# stop後の同期回収を伸ばしてもよい上限（混線が疑われる環境向け）
SAFETY_STOP_HARD_CAP_SEC = float(os.environ.get("TASO_SAFETY_STOP_HARD_CAP_SEC", "0.60"))

MODE_PLAY = "PLAY"
MODE_WATCH = "WATCH"
MODE_ANALYZE = "ANALYZE"
DEFAULT_MODE = os.environ.get("TASO_MODE", MODE_WATCH).upper()
if DEFAULT_MODE not in (MODE_PLAY, MODE_WATCH, MODE_ANALYZE):
    DEFAULT_MODE = MODE_WATCH

# =========================
# IO
# =========================
def out(s: str) -> None:
    try:
        sys.stdout.write(s + "\n")
        sys.stdout.flush()
    except BrokenPipeError:
        raise SystemExit(0)

def info(s: str) -> None:
    if SHOW:
        out("info string " + s)

def dbg(s: str) -> None:
    if DEBUG:
        try:
            sys.stderr.write("[TASO] " + s + "\n")
            sys.stderr.flush()
        except Exception:
            pass

# =========================
# Engine Wrapper
# =========================
class Engine:
    def __init__(self):
        self.p = subprocess.Popen(
            ENGINE_CMD,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            bufsize=1
        )
        self.q: queue.Queue[str] = queue.Queue()
        self.alive = True
        threading.Thread(target=self._reader, daemon=True).start()

    def _reader(self):
        assert self.p.stdout is not None
        for line in self.p.stdout:
            self.q.put(line.rstrip("\n"))
        self.alive = False

    def send(self, s: str) -> None:
        if self.p.stdin is None:
            return
        try:
            self.p.stdin.write(s + "\n")
            self.p.stdin.flush()
        except Exception:
            self.alive = False

    def recv(self, timeout: float = READ_TIMEOUT) -> Optional[str]:
        try:
            return self.q.get(timeout=timeout)
        except queue.Empty:
            return None

    def drain(self, limit: int = 200000) -> int:
        """queueの残骸を捨てる（誤読・混線防止）"""
        n = 0
        while n < limit:
            try:
                _ = self.q.get_nowait()
                n += 1
            except queue.Empty:
                break
        return n

    def close(self) -> None:
        try:
            self.send("quit")
        except Exception:
            pass
        try:
            self.p.terminate()
        except Exception:
            pass

# =========================
# Parsing helpers
# =========================
def _try_int(x: str) -> Optional[int]:
    try:
        return int(x)
    except Exception:
        return None

def parse_mate_token(tok: Optional[str]) -> Optional[int]:
    if tok is None:
        return None
    if tok.startswith("+"):
        tok = tok[1:]
    return _try_int(tok)

def prefix_len(a: str, b: str, k: int = PREFIX_K) -> int:
    aa = a.split()
    bb = b.split()
    n = 0
    for i in range(min(k, len(aa), len(bb))):
        if aa[i] != bb[i]:
            break
        n += 1
    return n

# USI指し手の簡易判定（安全確認に不正moveを投げないため）
_RE_MOVE = re.compile(r"^[1-9][a-i][1-9][a-i]\+?$")            # 7g7f / 7g7f+
_RE_DROP = re.compile(r"^[PLNSGBRK]\*[1-9][a-i]$")            # P*7f

def is_special_bestmove(mv: str) -> bool:
    mv = mv.strip().lower()
    return mv in ("resign", "win", "0000", "(none)")

def is_usi_move_token(mv: str) -> bool:
    mv = mv.strip()
    if not mv or is_special_bestmove(mv):
        return False
    return bool(_RE_MOVE.match(mv) or _RE_DROP.match(mv))

@dataclass
class Cand:
    mpv: int
    move: str
    pv: str
    cp: int
    mate: Optional[int]
    depth: int

@dataclass
class Features:
    stability: float
    opp_diff: float
    self_risk: float
    initiative: float
    winability: float
    label: str

def clamp(x: float, lo: float = 0.0, hi: float = 1.0) -> float:
    return max(lo, min(hi, x))

# =========================
# Winability v1.1
# =========================
def mate_risk(d: int) -> float:
    import math
    return clamp(MATE_RISK_FLOOR + (1.0 - MATE_RISK_FLOOR) * math.exp(-float(d) / MATE_RISK_TAU))

def mate_initiative(d: int) -> float:
    import math
    return clamp(MATE_INIT_FLOOR + (1.0 - MATE_INIT_FLOOR) * math.exp(-float(d) / MATE_INIT_TAU))

def _safe_best_cp(best_cp: int) -> int:
    # mateのみ等で±30000を入れても、相対計算の基準にすると壊れるのでガード
    return 0 if abs(best_cp) >= 20000 else best_cp

def compute_features(
    cand: Cand,
    best: Cand,
    context_cands: List[Cand],   # ※フィルタ前を渡す（mate負の気配も拾う）
    mode_hint: str
) -> Features:
    best_cp_used = _safe_best_cp(best.cp)
    cand_cp_used = 0 if abs(cand.cp) >= 20000 else cand.cp

    delta = best_cp_used - cand_cp_used

    pv_pref = prefix_len(best.pv, cand.pv, PREFIX_K)
    stability = clamp(pv_pref / float(max(1, PREFIX_K)))

    # “良い手”の数（局面内相対）— mate巨大cpに引きずられないよう best_cp_used を使う
    good = 0
    for c in context_cands:
        ccp = 0 if abs(c.cp) >= 20000 else c.cp
        if ccp >= best_cp_used - GOOD_CP_MARGIN:
            good += 1
    good = max(1, good)
    opp_diff = clamp(1.0 / float(good))

    # 自己危険度
    risk = 0.2
    if cand.mate is not None and cand.mate < 0:
        risk = 1.0
    else:
        if delta >= 300:
            risk = max(risk, 0.7)
        elif delta >= 180:
            risk = max(risk, 0.5)

    # 局面全体での mate負気配（フィルタ前の context から拾う）
    mate_neg_best = None
    for c in context_cands:
        if c.mate is not None and c.mate < 0:
            d = abs(c.mate)
            if mate_neg_best is None or d < mate_neg_best:
                mate_neg_best = d
    if mate_neg_best is not None:
        risk = max(risk, mate_risk(mate_neg_best))

    self_risk = clamp(risk)

    # Initiative
    initiative = 0.0
    if cand.mate is not None and cand.mate > 0:
        initiative = max(initiative, mate_initiative(abs(cand.mate)))

    initiative = max(initiative, clamp(1.0 - min(1.0, good / 5.0)))

    divergence = clamp((PREFIX_K - pv_pref) / float(max(1, PREFIX_K)))
    if mode_hint in ("DISTURB", "DESPERATE"):
        initiative = clamp(initiative + 0.25 * divergence)

    win = (
        0.30 * stability +
        0.25 * opp_diff +
        0.20 * (1.0 - self_risk) +
        0.25 * initiative
    )
    winability = clamp(win)

    if winability >= 0.75:
        tier = "安定勝ち"
    elif winability >= 0.55:
        tier = "勝負"
    elif winability >= 0.35:
        tier = "嫌味勝負"
    else:
        tier = "逆転狙い"

    if initiative >= 0.70 and self_risk <= 0.60:
        style = "攻め"
    elif stability >= 0.60 and self_risk <= 0.60:
        style = "安定"
    elif initiative >= 0.60 and self_risk >= 0.70:
        style = "開き直り"
    else:
        style = "バランス"

    label = f"{tier}/{style}"
    return Features(stability, opp_diff, self_risk, initiative, winability, label)

# =========================
# Candidate selection rules
# =========================
def decide_mode_from_best(best_feat: Features) -> str:
    w = best_feat.winability
    if w >= 0.75:
        return "STABLE"
    if w >= 0.55:
        return "BALANCE"
    if w >= 0.35:
        return "DISTURB"
    return "DESPERATE"

def rank_candidates(
    cands: List[Cand],
    feats: Dict[str, Features],
    best: Cand,
    phase_mode: str
) -> List[Cand]:
    best_cp_used = _safe_best_cp(best.cp)

    def key(c: Cand) -> Tuple[float, float, float]:
        f = feats[c.move]
        ccp = 0 if abs(c.cp) >= 20000 else c.cp
        delta = float(best_cp_used - ccp)
        pref = float(prefix_len(best.pv, c.pv, PREFIX_K))

        if phase_mode == "STABLE":
            return (f.winability, -delta, pref)
        if phase_mode == "BALANCE":
            return (f.winability, -pref, -delta)
        if phase_mode == "DISTURB":
            return (0.5 * f.initiative + 0.3 * f.opp_diff + 0.2 * f.winability, -pref, -delta)
        return (0.7 * f.initiative + 0.2 * f.opp_diff + 0.1 * f.winability, -pref, -delta)

    hard_limit = DROP_SOFT_LIMIT if phase_mode in ("STABLE", "BALANCE") else DROP_DISTURB_LIMIT

    kept: List[Cand] = []
    for c in cands:
        ccp = 0 if abs(c.cp) >= 20000 else c.cp
        delta = best_cp_used - ccp
        if delta <= hard_limit:
            kept.append(c)

    if not kept:
        kept = list(cands)

    kept.sort(key=key, reverse=True)
    return kept

# =========================
# Safety check (post-move)
# =========================
def _sync_stop_and_wait_bestmove(eng: Engine, rto: float, grace: float) -> None:
    """
    stop を送った後に bestmove を短時間回収して同期する。
    回収できなくても、その後 drain で混線を減らす。
    """
    eng.send("stop")
    t_stop = time.time() + max(0.01, grace)
    hard_cap = time.time() + max(0.05, SAFETY_STOP_HARD_CAP_SEC)
    # まずgrace、ダメならhard_capまで薄く粘る（混線回避を優先）
    while time.time() < t_stop:
        o = eng.recv(rto)
        if o and o.startswith("bestmove"):
            return
    while time.time() < hard_cap:
        o = eng.recv(rto)
        if o and o.startswith("bestmove"):
            return

def safety_check_after_move(
    eng: Engine,
    base_position: str,
    move: str
) -> bool:
    """
    moveを指した後の局面（相手番）で短時間探索。
    相手番なので、info mate +N は「相手が詰ます」= 自玉が詰む → unsafe。

    Patch:
    - 終了時に base_position を必要時のみ再送して局面を復元（状態汚染防止）
    - mate+ の誤検出を減らす：短手数は即unsafe / 長手数は複数回観測でunsafe
    - safety中だけ recv timeout を短くする
    """
    if not base_position.startswith("position"):
        return False
    if not is_usi_move_token(move):
        # resign/win等や不正トークンは safety 対象外（致命バグ回避）
        return False

    eng.drain()

    toks = base_position.split()
    if "moves" in toks:
        newpos = base_position + " " + move
    else:
        newpos = base_position + " moves " + move

    eng.send(newpos)
    eng.send(f"go movetime {SAFETY_MS}")

    unsafe = False
    t0 = time.time()
    deadline = t0 + max(
        SAFETY_DEADLINE_MIN_SEC,
        (max(1, SAFETY_MS) / 1000.0) * SAFETY_DEADLINE_FACTOR
    ) + SAFETY_DEADLINE_PAD_SEC

    got_bestmove = False
    mate_pos_hits = 0  # mate+ 観測回数

    # safety中は短めtimeoutで回す
    rto = min(READ_TIMEOUT, max(0.001, SAFETY_READ_TIMEOUT))

    broke_early = False
    while time.time() < deadline:
        o = eng.recv(rto)
        if o is None:
            continue

        if o.startswith("info") and " mate " in o:
            tt = o.split()
            if "mate" in tt:
                idx = tt.index("mate")
                m = parse_mate_token(tt[idx + 1] if idx + 1 < len(tt) else None)
                if m is not None and m > 0:
                    # 短手数は即unsafe（信頼度高）
                    if m <= max(1, SAFETY_MATE_MAX):
                        unsafe = True
                    else:
                        mate_pos_hits += 1
                        if mate_pos_hits >= max(1, SAFETY_MATE_REPEAT):
                            unsafe = True

        if o.startswith("bestmove"):
            got_bestmove = True
            break

        # unsafe が確定したら早めに抜ける（重さ軽減）
        if unsafe:
            broke_early = True
            break

    # bestmove未回収 or 早抜け は stop→bestmove回収で同期
    if not got_bestmove or broke_early:
        _sync_stop_and_wait_bestmove(eng, rto, SAFETY_STOP_GRACE_SEC)

    # 必要時のみ「局面復元」
    # - stopを投げた（＝同期処理をした）/ 早抜け / bestmove未回収だった場合に限定
    if (not got_bestmove) or broke_early:
        eng.send(base_position)

    eng.drain()
    return unsafe

# =========================
# Main USI loop
# =========================
def main() -> None:
    eng = Engine()

    current_position = ""
    user_mode = DEFAULT_MODE
    multipv = DEFAULT_MULTIPV

    def apply_engine_opts():
        eng.send(f"setoption name Threads value {THREADS}")
        eng.send(f"setoption name Hash value {HASH_MB}")
        eng.send(f"setoption name USI_Hash value {HASH_MB}")
        eng.send(f"setoption name HashSize value {HASH_MB}")
        eng.send(f"setoption name MultiPV value {multipv}")

    try:
        while True:
            raw = sys.stdin.readline()
            if not raw:
                break
            line = raw.strip()
            if not line:
                continue

            if line == "usi":
                eng.send("usi")
                while True:
                    o = eng.recv(READ_TIMEOUT)
                    if o is None:
                        continue
                    if o == "usiok":
                        out('option name TASO_Mode type combo default {} var PLAY var WATCH var ANALYZE'.format(DEFAULT_MODE))
                        out('option name TASO_MultiPV type spin default {} min 1 max 10'.format(DEFAULT_MULTIPV))
                        out('option name TASO_SafetyMs type spin default {} min 0 max 500'.format(SAFETY_MS))
                        out("usiok")
                        break
                    out(o)
                apply_engine_opts()
                continue

            if line.startswith("setoption"):
                toks = line.split()
                if "name" in toks:
                    i = toks.index("name")
                    name = toks[i + 1] if i + 1 < len(toks) else ""
                    value = ""
                    if "value" in toks:
                        j = toks.index("value")
                        value = " ".join(toks[j + 1 :]) if j + 1 < len(toks) else ""

                    if name == "TASO_Mode":
                        v = value.strip().upper()
                        if v in (MODE_PLAY, MODE_WATCH, MODE_ANALYZE):
                            user_mode = v
                            info(f"mode set => {user_mode}")
                        continue

                    if name == "TASO_MultiPV":
                        mv = _try_int(value.strip())
                        if mv is not None and 1 <= mv <= 10:
                            multipv = mv
                            info(f"multipv set => {multipv}")
                            apply_engine_opts()
                        continue

                    if name == "TASO_SafetyMs":
                        info("TASO_SafetyMs is fixed via env TASO_SAFETY_MS (restart required)")
                        continue

                eng.send(line)
                continue

            if line == "isready":
                eng.send("isready")
                t0 = time.time()
                while True:
                    o = eng.recv(READ_TIMEOUT)
                    if o is None:
                        if time.time() - t0 > 10.0:
                            out("readyok")
                            break
                        continue
                    if o == "readyok":
                        out("readyok")
                        break
                    if o.startswith("info"):
                        out(o)
                continue

            if line.startswith("position"):
                current_position = line
                eng.send(line)
                continue

            if line.startswith("go"):
                # go開始前に残骸を捨てる（安全確認などの混線対策）
                eng.drain()

                apply_engine_opts()
                eng.send(line)

                # depth最大優先で保持（mpvごとに安定化）
                cands_map: Dict[int, Cand] = {}
                best_engine_move: Optional[str] = None

                t_go = time.time()
                sent_stop = False
                already_resigned = False

                for _ in range(LINE_LIMIT):
                    # ハードタイムアウト
                    if time.time() - t_go > GO_HARD_SEC:
                        if not sent_stop:
                            eng.send("stop")
                            sent_stop = True
                            # stop後は少しだけbestmove待つ
                            t_go = time.time() - (GO_HARD_SEC - GO_STOP_GRACE_SEC)
                        else:
                            info("⚠ go timeout: bestmove not returned -> resign")
                            out("bestmove resign")
                            already_resigned = True
                            break

                    o = eng.recv(READ_TIMEOUT)
                    if o is None:
                        continue

                    if o.startswith("info"):
                        out(o)

                        tt = o.split()

                        # depth
                        depth = 0
                        if "depth" in tt:
                            d = _try_int(tt[tt.index("depth") + 1] if tt.index("depth") + 1 < len(tt) else "")
                            if d is not None:
                                depth = d

                        # mpv
                        mpv = 1
                        if "multipv" in tt:
                            m = _try_int(tt[tt.index("multipv") + 1] if tt.index("multipv") + 1 < len(tt) else "")
                            if m is not None:
                                mpv = m

                        # cp
                        cp = None
                        if "score" in tt and "cp" in tt:
                            cp = _try_int(tt[tt.index("cp") + 1] if tt.index("cp") + 1 < len(tt) else "")

                        # mate
                        mate = None
                        if "mate" in tt:
                            mate = parse_mate_token(tt[tt.index("mate") + 1] if tt.index("mate") + 1 < len(tt) else None)

                        # pv
                        if "pv" in tt:
                            i_pv = tt.index("pv")
                            if i_pv + 1 < len(tt):
                                pv = " ".join(tt[i_pv + 1 :])
                                mv = tt[i_pv + 1]

                                # cp欠損時の暫定（mate優先、ただし相対計算でガードする）
                                if cp is None:
                                    if mate is not None:
                                        cp = 30000 if mate > 0 else -30000
                                    else:
                                        cp = 0

                                prev = cands_map.get(mpv)
                                if prev is None or depth >= prev.depth:
                                    cands_map[mpv] = Cand(mpv=mpv, move=mv, pv=pv, cp=cp, mate=mate, depth=depth)
                        continue

                    if o.startswith("bestmove"):
                        parts = o.split()
                        best_engine_move = parts[1] if len(parts) >= 2 else None
                        break

                    out(o)

                if already_resigned:
                    continue

                if best_engine_move is None:
                    out("bestmove resign")
                    continue

                cands = list(cands_map.values())
                if not cands:
                    out(f"bestmove {best_engine_move}")
                    continue

                # bestはmpv1優先
                best = cands_map[1] if 1 in cands_map else max(cands, key=lambda c: c.cp)

                # 頓死回避 第1段：見えてる自玉mate負は候補から落とす（表示用候補）
                safe_cands = [c for c in cands if not (c.mate is not None and c.mate < 0)]
                if not safe_cands:
                    safe_cands = cands

                # short mateの検出（表示用）
                short_mate = None
                for c in safe_cands:
                    if c.mate is not None and c.mate > 0:
                        if short_mate is None or c.mate < short_mate[0]:
                            short_mate = (c.mate, c.move)

                # 特徴量は「フィルタ前のcands」をcontextとして使う（mate負気配を拾う）
                tmp_best_feat = compute_features(best, best, cands, "BALANCE")
                phase_mode = decide_mode_from_best(tmp_best_feat)

                feats_by_move: Dict[str, Features] = {}
                for c in safe_cands:
                    feats_by_move[c.move] = compute_features(c, best, cands, phase_mode)

                ranked = rank_candidates(safe_cands, feats_by_move, best, phase_mode)

                # ===== bestmove（指す手）は強さ維持 =====
                chosen = best_engine_move

                # エンジンbestがPV内で自玉mate負なら、最良のsafeへ
                for c in cands:
                    if c.move == chosen and (c.mate is not None and c.mate < 0):
                        info("⚠ bestmove shows self-mate in PV -> fallback to safest")
                        chosen = max(safe_cands, key=lambda x: x.cp).move
                        break

                # 頓死回避 第2段：着手後安全確認（短時間）
                # resign/win/0000 等は safety 対象外（致命バグ回避）
                if SAFETY_MS > 0 and current_position and is_usi_move_token(chosen):
                    unsafe = safety_check_after_move(eng, current_position, chosen)
                    if unsafe:
                        info(f"☠ safety-check failed for {chosen} -> fallback")
                        alt = None
                        for c in ranked[: min(5, len(ranked))]:
                            if c.move == chosen:
                                continue
                            if not is_usi_move_token(c.move):
                                continue
                            if safety_check_after_move(eng, current_position, c.move):
                                continue
                            alt = c.move
                            break
                        if alt is not None:
                            chosen = alt
                        else:
                            info("☠ no alternative passed safety-check (keep chosen)")

                # ===== 表示（候補提示） =====
                if user_mode == MODE_PLAY:
                    f_best = feats_by_move.get(best.move)
                    if f_best:
                        info(f"[TASO] phase={phase_mode} win(bestPV)={f_best.winability:.2f} {f_best.label}")
                    if short_mate and short_mate[0] <= MATE_SHORT_MAX:
                        info(f"⚡ short-mate seen: mate {short_mate[0]} (pv move {short_mate[1]})")

                elif user_mode == MODE_WATCH:
                    f_best = feats_by_move.get(best.move)
                    if f_best:
                        info(f"[TASO] phase={phase_mode} win(bestPV)={f_best.winability:.2f} {f_best.label}")
                    if short_mate and short_mate[0] <= MATE_SHORT_MAX:
                        info(f"⚡ short-mate seen: mate {short_mate[0]} (pv move {short_mate[1]})")

                    show_n = min(3, len(ranked))
                    for i in range(show_n):
                        c = ranked[i]
                        f = feats_by_move[c.move]
                        cp_disp = c.cp
                        if abs(cp_disp) >= 20000:
                            info(f"候補{i+1}: {c.move}  cp=mate-only  win={f.winability:.2f}  {f.label}")
                        else:
                            delta = (_safe_best_cp(best.cp) - (0 if abs(c.cp) >= 20000 else c.cp))
                            info(f"候補{i+1}: {c.move}  cp={cp_disp:+d} Δ={delta:+d}  win={f.winability:.2f}  {f.label}")

                else:  # ANALYZE
                    f_best = feats_by_move.get(best.move)
                    if f_best:
                        info(f"[TASO] phase={phase_mode} win(bestPV)={f_best.winability:.2f} {f_best.label}")
                    show_n = min(max(5, multipv), len(ranked))
                    for i in range(show_n):
                        c = ranked[i]
                        f = feats_by_move[c.move]
                        if abs(c.cp) >= 20000:
                            info(f"[{i+1}] {c.move}  cp=mate-only  win={f.winability:.2f} "
                                 f"(stab={f.stability:.2f} diff={f.opp_diff:.2f} risk={f.self_risk:.2f} init={f.initiative:.2f}) "
                                 f"{f.label}")
                        else:
                            delta = (_safe_best_cp(best.cp) - (0 if abs(c.cp) >= 20000 else c.cp))
                            info(f"[{i+1}] {c.move}  cp={c.cp:+d} Δ={delta:+d}  win={f.winability:.2f} "
                                 f"(stab={f.stability:.2f} diff={f.opp_diff:.2f} risk={f.self_risk:.2f} init={f.initiative:.2f}) "
                                 f"{f.label}")

                out(f"bestmove {chosen}")
                continue

            if line == "quit":
                break

            eng.send(line)

    finally:
        eng.close()

if __name__ == "__main__":
    main()
